## 캡슐화

### 7.1 레코드 캡슐화하기

레코드
```
{name: "진도", age: 9999}
```

- 레코드의 단점: 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번거롭다
- 클래스: 사용자가 무엇이 저장된 값이고 계산된 값인지 알 필요가 없다

**예시** 

- 상수 자체를 함수로 캡슐화한다
- 객치로 만들고 객체를 반환한다
- 게터와 세터를 추가한다
- 필드로 펼쳐둔다

**예시 - 중첩된 레코드 캡슐화하기**

- 중첩된 구조 읽는 방법
- 읽는 코드를 모두 독립 함수로 빼는 방법
- 장점: 명시적이다
- 단점: 읽는 경우마다 코드 수 증가
- 복제본 제공
- 단점: 데이터 구조가 클수록 복제 비용이 증가 -> 성능이 느려질 수 있다
- 레코드 캡슐화를 재귀적으로

### 7.2 컬렉션 캡슐화하기

- 컬렉션의 원소가 바뀔 수 있다
- 복제본을 리턴하고 컬렉션 변경자 메서드 제공
- `aCustomer.oders.size()` -> `aCustomer.numberOfOders()`
- 표준 인터페이스 대신 전용 메서드들을 사용하게 하면 부가적인 코드가 상당히 늘어나며 컬렉션 연산들을 조합해 쓰기도 어려워진다
- 



