### 6.8 매개변수 객체 만들기
데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해지는 이점을 얻는다. 그리고 함수가 데이터 구조를 받게 하면 매개변수 수가 줄어든다.
같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기 때문에 일관성도 높여준다.

이 리팩터링의 진정한 힘은 코드를 더 근본적으로 바꿔준다는 데 있다.

<br>

<절차>
1. 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
2. 테스트한다.
3. 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
4. 테스트한다.
5. 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
6. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
7. 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.

<br>

### 6.9 여러 함수를 클래스로 묶기
클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.
클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다.
또한 이런 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.

이미 만들어진 함수들을 재구성할 때, 새로 만든 클래스와 관련하여 놓친 연산을 찾아서 새 클래스의 메서드로 뽑아내는 데도 좋다.

함수를 한데 묶는 또 다른 방법으로 여러 함수를 변환 함수로 묶기도 있다.
이런 함수들을 중첩 함수 형태로 묶어도 된다. 

<br>

<절차>
1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.
3. 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.

<br>

### 6.10 여러 함수를 변환 함수로 묶기
변환 함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.
이렇게 해두면 도출과정을 검토할 일이 생겼을 때 변환 함수만 살펴보면 된다.

혹은 여러 함수를 클래스로 묶기로 처리해도 된다.

이 둘 사이에는 차이가 있는데, 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 낫다.
여러 함수를 한데 묶는 이유는 도출 로직이 중복되는 것을 피하기 위해서이다.

<br>

<절차>
1. 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다.
2. 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
3. 테스트한다.
4. 나머지 관련 함수도 위 과정에 따라 처리한다.

<br>

### 6.11 단계 쪼개기
코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서 별개로 나누는 방법을 고민한다.
이렇게 분리하는 가장 간편한 방법 하나는 동작을 연이은 두 단계로 쪼개는 것이다.

<br>

<절차>
1. 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
2. 테스트한다.
3. 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
4. 테스트한다.
5. 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
6. 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다.
