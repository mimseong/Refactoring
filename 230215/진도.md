**1.1 자 시작해보자**

**1.2 예시 프로그램을 본 소감**

- 코드가 길다면 작동방식 파악하기 쉽게 함수로 쪼개기
- 기능을 추가하기 쉬운 형태로 리팩터링 하고 나서 원하는 기능 추가
- 함수 복붙해서 두 개 만들지 마라
- 정책 같은 경우는 변경될 가능성이 높음에 유의해라

**1.3 리팩터링의 첫 단계**

- 리팩터링 전 제대로 된 테스트를 마련해야 한다
- 언제든 실수할 수 있다

**1.4 statement()함수 쪼개기**

- 일부 함수를 추출해보자
- 함수에서 사용할 변수 추출
- 함수 내에서 변경되지 않는 변수는 매개변수로 전달
- 변경사항이 있는 변수는 반환
- 수정할 때마다 테스트 -> 커밋
- 변수를 알기 쉽게 변경
- 변수 인라인하기
  - 함수 결과를 저장하는 변수를 만들지말고 함수 자체를 호출한다
- format 함수 대신에 함수의 기능에 맞는 이름을 붙였다 (화폐 단위 맞추기)
- 변수 이름 짓기
  - 당장 떠오르는 최선의 이름 사용
  - 나중에 더 좋은 이름이 떠오르면 바꾸기
  - 보통은 2번은 읽어야 적합한 이름이 떠오른다
- 반복문 쪼개기
  - 값 누적하는 부분 분리
  - 문장 슬라이드 (변수 사용하는 곳으로 옮기기)
  - 함수로 쪼개기
  - 변수 인라인 (변수 대신 함수 호출하기)
- 반복문 두 번 돌면 성능이 안 좋아지지 않을까?
  - 성능 차이는 미미하다
  - 리팩터링으로 깔끔하고 빠른 코드를 얻을 수 있다

**1.5 중간 점검: 난무하는 중첩 함수**

**1.6 계산 단계와 포맷팅 단계 분리하기**

- 데이터 생성, html 표현: 두 가지 기능을 각각 함수로 분리하자
- immutable하게 복사해서 넘긴다
- 반복문 같은 경우도 파이프라인으로 변경

**1.7 중간 점검: 두 파일로 분리됨**

- 항시 코드베이스를 작업 시작 전보다 건강하게 만들어 놓고 떠나야 한다

**1.8 다형성을 활용해 계산 코드 재구성하기**

- case문 -> 다형성을 활용
- 서브클래스를 생성해서 호출하는 쪽은 계산 함수만 호출하면 되게끔
- get amount() <- 이렇게 함수 선언하는거 신기해
- 팩터리 함수로 분리
  - 팩터리 함수에서 서브 클래스 생성자 호출
- 공통 함수는 슈퍼클래스에 두고 필요시 서브 클래스에서 오버라이드

**1.9 상태 점검: 다형성을 활용하여 데이터 생성하기**

- 클래스를 분리하므로서 장르를 추가하기 용이해졌다

**1.10 마치며**

- 좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가다.
- 프로그래밍 팀의 현재와 이상의 차이에 항상 신경 쓰면서, 이상에 가까워지도록 리팩터링해야한다
- 단계를 잘게 나누자



**깨달은 것들**

- 매개변수의 역할이 뚜렷하지 않을 때는 부정관사 a/an 을 붙인다
- 처음본다?? 역할이 안 뚜렷하면 뚜렷하게 하는게 낫지 않을까?
- 48p a = getA() 이런게 불편했단 말이야
- (get 붙이는 부분이)
- 이런 것들 전부 변수 인라인해서 a()로 사용하면 좋겠다!! 


