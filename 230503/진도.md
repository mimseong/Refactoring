## 12장 상속 다루기     

### 12.1 메서드 올리기

- 중복 코드 제거는 중요하다
- 무언가 중복되었다는 것은 한 쪽의 변경이 다른 쪽에 반영되지 않을 수 있다는 위험을 수반한다
- 메서드의 본문이 똑같다 -> 부모 클래스로 올리자

```
get monthlyCost() {
  // 서브클래스가 monthlyCost 함수를 구현해야 한다는 사실을 알린다
  throw new SubclassResponsibilityError()
}
```

### 12.2 필드 올리기

- 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올린다
- 데이터 중복 선언을 없앨 수 있다
- 해당 필드를 사용하는 동작을 슈퍼클래스로 올릴 수 있다

### 12.3 생성자 본문 올리기

- 어....

```
class Party {}

class Employ extends Party {
  constructor(name, id) {
    this._name = name
    this._id = id
  }
}
```

변경
- name을 슈퍼 클래스로 옮겼다

```
class Party {
  constructor(name) {
    this._name = name
  }
}

class Employ extends Party {
  constructor(name, id) {
    super(name)
    this._id = id
  }
}
```

### 12.4 메서드 내리기

- 서브 클래스 하나만 관련된 메서드는 슈퍼클래스에서 제거하고 서브 클래스에 추가하는 편이 깔끔하다

### 12.5 필드 내리기

- 서브 클래스 하나만 관련된 필드는 슈퍼클래스에서 서브클래스로 이동하자

### 12.6 타입 코드를 서브 클래스로 바꾸기

- 비슷한 대상을 특정 특성에 따라 구분해야 할 때 타입코드를 서브클래스로
- 서브클래스의 이점
  - 조건에 따라 다르게 동작하도록 다형성 제공
  - 타입 코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 특히 유용
  - 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드
  - 필요한 서브클래스만 가지도록 정리할 수 있다

### 12.7 서브클래스 제거하기

- 필요없는 서브 클래스 제거하자

### 12.8 슈퍼 클래스 추출하기

- 비슷한 일을 수행하는 두 클래스가 보이면 비슷한 부분을 공통의 슈퍼 클래스로 옮겨담을 수 있다
- 상속은 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 주로 사용

### 12.9 계층 합치기

- 리팩터링 진행하다가 부모와 자식이 너무 비슷하면 그냥 합쳐버리자

### 12.10 서브클래스를 위임으로 바꾸기

- 상속의 단점
  - 달라져야 하는 이유가 여러 개라도 하나의 이유만으로 선택해 기준잡을 수 밖에 없다
  - 나이대 -> (젊은이, 어르신), 소득수준 -> (부자, 서민)
  - 나이대와 소득수준 두 가지 기준을 잡을 수 없다
  - 클래스들의 관계가 아주 긴밀하게 결합된다
  - 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기가 쉽다
- 위임을 사용한다면
  - 상속보다 결합도가 훨씬 약하다
  - `클래스 상속 보다는 객체 컴포지션을 사용하라`
  - 컴포지션: 다른객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 메서드를 호출하는 기법
  - 여기서 컴포지션은 위임과 같은 말


### 12.11 슈퍼클래스를 위임으로 바꾸기

- 상속이 혼란과 복잡도를 키울 수 있다
- ex) 자바의 스택 클래스
  - 스택은 리스트를 상속받음
  - 리스트의 연산 중 스택에 적용되지 않더라도 스택 인터페이스에 노출된다
  - 스택에 리스트 객체를 필드에 저장해두고 필요한 기능만 위임하는게 더 나았을 것이다
- 슈퍼클래스의 기능들이 서브클래스에 어울리지 않는다면 그 기능을 상속을 통해 이용하면 안 된다
- 위임을 이용하면 기능 일부만 빌려올 뿐인, 서로 별개의 개념임이 명확해진다
- 위임의 단점
  - 위임의 기능을 이용할 호스트의 함수 모두를 전달 함수로 만들어야 한다는 점

```
constructor() {
  this._catalogItem = new CatalogItem(id, title, tags)
}
```

- 상속을 받지 말고 슈퍼 클래스를 객체로 생성한다

```
get id() {return this._catalogItem.id;}
```

- 슈퍼클래스의 함수를 모두 전달함수로 변환한다
- 마지막으로 상속 관계를 끊는다

