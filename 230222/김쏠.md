# CHAPTER 02 리팩터링 원칙

## 2.1 리팩터링 정의
> [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법  
> [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

즉, 리팩터링은 재구 **특정한 방식에 따라 코드를 정리하는 것** 이다.   

* 함수 추출을 거치면 성능이 변할 순 있지만 **사용자 관점에서는 달라지는 점이 없어야** 한다.   
* 리팩터링 과정에서 발견된 버그는 **리팩터링 후에도 그대로 남아 있어야** 한다.(단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮다.)   
* 리팩터링은 성능 최적화와 비슷하지만 코드를 이해하고 수정하기 쉽게 만드는 것이다.

## 2.2 두 개의 모자
소프트웨어를 개발할 때 목적을 명확하게 구분하여 작업한다.   
기능을 추가할 때는 기존 코드는 절대 건드리지 않고 새 기능만 추가하고,   
반대로 리팩터링할 때는 기능 추가는 절대 하지 않기로 다짐하고 코드 재구성에만 전념한다.   
👉 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

## 2.3 리팩터링하는 이유
### 1️⃣소프트웨어 설계가 좋아진다.
아키텍처를 충분히 이해하기 못한 채 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.   
설계가 나쁘면 코드가 길어지고 중복된 코드가 빈번하게 나타날 수 있어 **`중복 코드 제거`** 는 설계 개선 작업의 중요한 역할을 한다.   
코드량을 줄인다고 시스템이 빨라지는 건 아니지만 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다. 

### 2️⃣소프트웨어를 이해하기 쉬워진다.
리팩터링은 코드가 더 잘 읽히게 도와준다.   
나중에 다른 사람을 배려하기 위한 것도 있지만, 다른 사람이 나 자신일 때가 많아 기억할 필요가 있는 것들은 최대한 코드에 담으려고 한다.   

### 3️⃣버그를 쉽게 찾을 수 있다.
**`코드를 이해하기 쉽다 == 버그를 찾기 쉽다.`**   
리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 깨달은 것을 코드에 바로 반영하게 된다.   
단순히 가정만 했던 것들이 명확해진다.

### 4️⃣프로그래밍 속도를 높일 수 있다.
내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있어 빠르게 개발할 수 있는 상태를 오래 지속할 수 있다.   
또한 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.    

👉리팩터링하면 기존 설계를 얼마든지 개선할 수 있으므로, 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다. 

## 2.4 언제 리팩터링해야 할까?
	1. 그냥 한다.
	2. 비슷한 일을 두 번째로 하더라도 일단 계속 한다.
	3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

### ✅준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.   
현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.   

만약 두 함수의 로직이 비슷하고 리터럴 값만 다르다면, [다른 값만 매개변수로 받아 처리하는 함수 만들어](https://refactoring.com/catalog/parameterizeFunction.html) 중복을 없앤다.   
버그를 잡을 때도 오류를 일으키는 코드가 세 곳에 퍼져 있다면, 한 곳으로 합쳐 작업하는 것이 훨씬 편하고,   
질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여 생기는 오류를 줄일 수 있다.   
👉 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에 같은 곳에서 다른 버그가 발생할 가능성을 줄인다.

### ✅이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기
리팩터링하면 머리로 이해한 것을 코드에 담을 수 있고 수정한 코드를 테스트해보면서 내 생각이 맞았는지 확인할 수 있다.   
리팩터링을 하면서 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누어 코드를 깔끔하게 정리한다.

### ✅쓰레기 줍기 리팩터링
리팩터링을 하다보면 관련 없는 일에 많은 시간을 뺏길 수도 있다.   
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 걸리는 일은 짧은 메모만 남긴 다음 하던 일을 끝내고 처리하는 방법을 `쓰레기 줍기 리팩터링`이라 한다.   
리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는 다는 것.   

### ✅계획된 리팩터링과 수시로 하는 리팩터링
저자는 리팩터링 일정을 따로 잡지 않고 기능을 추가하거나 버그를 잡는 동안에도 리팩터링을 함께 한다.   
그정도로 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에 도움을 준다.   
보기 싫은 코드는 당연히 리팩터링해야 하지만 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.   
뛰어난 개발자는 **새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길**이란 걸 안다.   

### ✅오래 걸리는 리팩터링
오래 걸리는 리팩터링도 있지만, 팀 전체가 리팩터링에 매달리는 것에는 회의적.   
한 번에 몰두하는 것보다는 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많으며,   
**`리팩터링은 코드를 깨트리지 않는다`** 는 장점을 활용하여 관련 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 것을 추천한다.

### ✅코드 리뷰에 리팩터링 활용하기
리팩터링은 다른 이의 코드를 리뷰하는 데 도움된다. 👉 상상으로 그치는 것이 아닌 실제로 적용하여 눈으로 확인할 수 있기 때문.   
리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움된다. 👉 제시하는 데서 그치는 것이 아닌 상당수를 즉시 구현해볼 수 있기 때문.   
가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것(= 짝 프로그래밍)

### ✅관리자에게는 뭐라고 말해야 할까?
새 함수를 추가하려는데 현재 설계가 적합하지 않다면 먼저 리팩터링하고 나서 함수를 추가하는 편이 빠르다.   
버그를 수정하려면 현재 소프트웨어의 작동 방식을 이해해야 한다.   
**`개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.`**

### ✅리팩터링하지 말아야 할 때
* 외부 API처럼 호출해서 쓰는 코드
* 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때 --> 뛰어난 판단력과 경험이 뒷받침돼야 하기 때문에 이 판단에 대해서는 한 마디 조언으로 표현하기는 어렵다. 

## 2.5 리팩터링 시 고려할 문제
### ✅새 기능 개발 속도 저하
> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.   

리팩터링을 과도하게 하는 경우보단 거의 하지 않는 경우가 훨씬 많아 리팩터링을 더 자주 하도록 노력해야 한다.   
`리팩터링은 클린 코드와 다르다`   
**리팩터링은 개발 기간 단축, 기능 추가 시간 단축, 버그 수정 시간 단축** 등 경제적인 이유로 하는 것이다.   

### ✅코드 소유권
코드 소유권이 나뉘어 있으면(ex. API) 리팩터링에 방해가 되지만, 리팩터링을 할 수 없는 건 아니고 제약이 있을 뿐이다.   
코드 소유권을 한 사람이 갖기, 팀원 각자가 상대방에게 공개 인터페이스를 제공하는 등 방법은 많지만 저자가 선호하는 방식은 `코드 소유권을 팀에 두는 것`이다.   
팀원이라면 누구나 소유한 코드를 수정하게 할 수 있게 하는 느슨한 방식은 대규모 시스템 개발 시 잘 어울린다.   

### ✅브랜치
장점
- 작업이 끝나지 않은 코드가 마스터에 섞이지 않는다.
- 추가될 때마다 버전을 명확하게 나눌 수 있다. 
- 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있다. 

단점
- 독립 브랜치로 작업하는 기간이 길어질수록 마스터로 통합하기가 어려워진다.
- 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 다른 사람이 그 내용을 볼 수 없다. 
- 통합한 뒤에는 마스터에서 달라진 내용을 내 브랜치에 머지해야 하는데, 상당한 노력이 들 수도 있다.
- 내 브랜치에서만 프로그램이 동작하지 않을 수도 있다. 

이런 단점을 해결하기 위해 나온 것이 바로 지속적인 통합(CI)이다.   

`지속적인 통합(Continuous Integration, CI)`   
> 기능별 브랜치의 통합 주기를 짧게 관리하는 것

CI를 적용하기 위해 마스터를 건강하게 유지하고, 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 기능(토글)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.   
CI는 머지의 복잡도를 줄일 수 있을 뿐만 아니라 리팩터링과 궁합이 아주 좋다.   

리팩터링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있다.   
기능별 브랜치를 사용하면 안 된다는 말은 아니지만, 브랜치를 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있다.   

### ✅테스팅
리팩터링의 특성은 프로그램의 동작은 똑같이 유지된다는 것이다.   
리팩터링은 단계별 변경 폭이 작아서 오류의 원인이 되는 코드 범위도 넓진 않지만 핵심은 **오류를 빨리 잡는** 데 있다.   

### ✅데이터베이스
데이터베이스도 리팩터링을 통해 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.   
다른 리팩터링과 다른 점이 있다면 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 좋다는 것이다.   

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
