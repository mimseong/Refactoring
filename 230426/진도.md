
#  11장 API 리팩터링



## 11.1 질의 함수와 변경함수 분리하기

- 부수효과가 있는 부분과 없는 부분 분리
- 부수효과가 전혀 없이 값을 반환해주는 함수 추구해야 한다
- 부수효과가 없는 함수
  - 원하는 만큼 호출해도 아무 문제가 없다
  - 함수를 옮기기 쉽다
  - 테스트하기도 쉽다
  - 이용할 때 신경 쓸 거리가 매우 적다

**예시**

- 경고하는 부분과 찾는 부분을 분리했다
- 변경함수와 질의함수는 중복된 부분이 많아서 변경함수에서 질의 함수를 사용하도록 수정했다

## 11.2 함수 매개변수화하기

- 함수의 동작이 거의 비슷하고 리터럴 값이 다른 경우 리터럴을 매개변수로 받기

**예시**

- 범위를 다루는 로직은 중간에 해당하는 함수에서 시작하는게 좋다
- `middleBend`
- 함수를 파악해서 하한과 상한을 매개변수로 분리한다
- Infinity
  - 자바스크립트에 미리 정의된 변수
  - 양의 무한대
  - 1/0 -> Infinity가 나온다

## 11.3 플래그 인수 제거하기

- 플래그인수: 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위함
- 플래그인수의 단점
  - 함수를 이해하기 어려워진다
  - 플래그인수로 어떤 값을 넘겨야 하는지 알아내야 한다
  - 뜻을 온전히 전달하지 못한다
- 플래그인수가 둘 이상이다: 함수 하나가 너무 많은 일을 처리하고 있다

**예시**

- `deliveryDate(onOrder, true)`
- true가 뭘 의미하는지 알기 어렵다
- `isRush` 플래그인수 대신에 `rushDeliveryDate` 함수 사용

## 11.4 객체 통째로 넘기기

- 하나의 레코드에서 값을 두어개 뽑아서 넘기는 경우 객체를 통으로 옮겨보자
- 함수가 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다
- 매개변수 목록이 짧아져서 일반적으로는 함수 사용법을 이해하기 쉬워진다
- 사용하지 않는경우
  - 함수가 레코드 자체에 의존하기를 원하지 않을 때
  - 레코드와 함수가 서로 다른 모듈에 속해있을 때, 함수를 객체로 보내야 하는 건 아닌지 생각해보자


## 11.5 매개변수를 질의함수로 바꾸기

- 매개변수 목록은 함수의 변동 요인을 모아놓은 곳
- 매개변수 목록도 중복은 피하는게 좋으며 짧을수록 이해하기 쉽다
- 함수 내에서 쉽게 결정할 수 있는 값을 매개변수로 넘기는 것도 중복
- 매개변수를 질의 함수로 바꾸지 말아야 하는 경우
  - 원치 않는 의존성이 생기는 경우
  - ex) 함수가 몰랐으면 하는 프로그램 요소에 접근해야 하는 상황

## 11.6 질의함수를 매개변수로 바꾸기

- 참조를 매개변수로: 참조를 풀어내는 책임을 호출자로 옮긴다
- 참조 투명성: 똑같은 값을 건네면 매번 똑같은 결과를 낸다
- 참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃게 된다
- 이럴 경우 해당 원소를 매개변수로 바꾸면 된다
- 모듈 개발시, 순수함수들을 따로 구분, 프로그램의 입출력과 기타 가변원소를 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴 활용


**예시**

- 함수 내부에서 전역 객체를 쓰고 있다
- 변수를 추출해서 매개변수로 받도록 변경

```
이 리팩터링을 쓰면 호출하는 쪽 코드는 전보다 다루기 어려워지는 게 보통이다.
'의존성을 모듈 밖으로 밀어낸다'함은 그 의존성을 처리하는 책임을 호출자에게 지운다는 뜻이기 때문이다.
결합도를 낮춘 효과에 대한 반대급부인 셈이다.
```


## 11.7 세터 제거하기

- 객체 생성 후 수정되지 않길 원하는 필드라면 세터를 제공하지 말자
- 필드는 오직 생성자에서만 설정, 변경될 가능성이 없어진다

## 11.8 생성자를 팩터리 함수로 바꾸기

- 생성자: 객체를 초기화하는 특별한 용도의 함수
- 생성자의 제약으로 인해 팩터리 함수로 생성자를 호출하도록 할 수 있다

## 11.9 함수를 명령으로 바꾸기

- 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 경향이 있다
- 명령의 장점
  - 평범한 함수 보다 훨씬 유연하게 함수를 제어할 수 있다
  - undo 같은 보조 연산 제공
  - 수명주기 더 정밀하게 제어
  - 상속과 훅을 사용해서 사용자 맞춤형으로 (????)
  - 일급함수를 지원하지 않는 언어에서 일급함수 기능 대부분을 흉내낼 수 있다

## 11.10 명령을 함수로 바꾸기

- 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크다

## 11.11 수정된 값 반환하기

- 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 중요하다
- 변수를 갱신하는 함수라면 수정된 값을 반환하여 호출자가 그 값을 변수에 담아두도록 하는 것이다

```
let totalAscent = 0
calculateAscent(); // totalAscent 값 수정 (데이터가 변경되는지 알기 어렵다)
```

```
const totalAscent = calculateAscent(); // 변수가 갱신될 것임을 분명하게 인지하게 된다
```

## 11.12 오류 코드를 예외로 바꾸기

- `return -23` 대신 예외를 던지자
- 예외: 독립적인 오류 처리 매커니즘
- 오류가 발견되면 예외를 던진다
- 적절한 예외 핸들러를 찾을 때까지 콜스택을 타고 위로 전파된다
- 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다
- 예외 대신에 종료를 넣는다고 생각해보자
- 종료되어야 하는게 맞다면 예외를 사용
- 종료되어서는 안 되면 오류를 검출하여 프로그램을 정상 흐름으로 되돌리게끔 처리


## 11.13 예외를 사전 확인으로 바꾸기

- 예외 대신 미리 검사
- 함수 수행시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외 대신에 미리 검사하도록 하자

  
