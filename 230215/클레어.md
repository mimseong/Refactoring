## Chapter 01 리팩터링: 첫 번째 예시

### 1.1 예시 코드

### 1.2 예시 프로그램을 본 소감
> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.  
> 리팩터링이 필요한 이유는 바로 이러한 변경 때문이다.

### 1.3 리팩터링의 첫 단계
리팩터링에서 테스트의 역할은 굉장히 중요하다. ~디지털 시대의 연약한 자여, 그대 이름은 소프트웨어.~
> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

### 1.4 statement() 함수 쪼개기
switch문 함수를 따로 빼서 함수를 추출한다.
> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

### 1.5 중간 점검: 난무하는 중첩 함수
계산 로직은 모두 함수로 빼냈기 때문에 흐름을 이해하기가 쉬워졌다.

### 1.6 계산 단계와 포맷팅 단계 분리하기

### 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨
코드량은 부쩍 늘었다. 하지만 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되었다.
모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다.

> 캠핑자들에게는 "도착했을 때보다 깔끔하게 정돈하고 떠난다."는 규칙이 있다. 프로그래밍도 마찬가지다. 항상 코드베이스를 작업 시작 전보다 건강하게 만들어놓고 떠나야 한다.

### 1.8 다형성을 활용해 계산 코드 재구성하기
: 조건부 로직을 다형성으로 바꾸기

### 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

### 1.10 마치며
리팩터링을 크게 세 단계로 진행했다. 
- 원본 함수를 중첩 함수 여러 개로 나눈다.
- 단계 쪼개기를 적용해서 계산 코드와 출력 코드를 분리한다.
- 각 단계에서 코드 구조를 보강하여 코드가 수행하는 일이 더욱 분명하게 드러나도록 한다.

> 좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가다.
