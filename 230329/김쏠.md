# Chapter 07. 캡슐화
## 7.1 레코드 캡슐화하기
**배경**   
대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다.   
레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로 전달할 수 있게 해준다.   
하지만, 어떤 식으로 계산하든 **시작**과 **끝**과 **길이**를 알 수 있어야 한다.   
(계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해야 한다.)     

💫가변 데이터를 저장하는 용도로는 객체 선호   
- 객체를 사용하면 어떻게 저장했는지를 숨긴 채 시작, 끝, 길이의 값을 각각의 메서드로 제공할 수 있다. 
- 객체를 사용하면 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다.   

💫불변 데이터는 단순히 시작, 끝, 길이를 모두 구해서 레코드에 저장한다.   
<br>
레코드는 2가지로 구분할 수 있다.   
1️⃣ 필드 이름을 노출하는 형태의 레코드   
2️⃣내가 원하는 이름을 쓸 수 있는 형태의 레코드   
ex) 해시, 맵, 해시맵, 딕셔너리, 연관 배열 등   

+) 해시맵은 다양한 작업에 유용하지만 필드를 명확히 알려주지 않는다는 게 단점이 될 수 있다.   
범위를 {시작, 끝} 혹은 {시작, 길이} 중 어느 것을 표현하고 있는지 알아내는 방법은 직접 코드를 확인하는 방법이다.   
해시맵을 쓰는 부분이 적다면 문제가 되지 않지만 사용하는 곳이 많을수록 불분명해진다.   
<br>

저자는 덩치 큰 데이터 구조를 다룰 때 **데이터를 쓰는** 부분에 집중한다고 한다.   
(캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한 곳에 모아두는 일이 중요하다.)   
쓰는 부분을 찾아 수정하다보면 빠진 건 없는지 확인해야 하는데 이때 확인할 수 있는 방법은    
1. 깊은 복사하여 반환하기
2. 읽기전용 프락시 반환하기   
3. 복제본을 만들고 재귀적으로 동결해서 쓰기 동작 감지하기
<br>

그렇다면 **읽기**는 어떻게 다뤄야 할까?   
1. 읽는 코드를 모두 독립 함수로 추출한 다음 클래스로 옮긴다. 
    - 모든 쓰임을 명시적인 API로 제공한다는 건 장점. (하지만 읽는 패턴이 다양하면 그만큼 작성할 코드가 늘어난다. )   
2. 내부 데이터를 복제해서 제공한다.   
3. 레코드 캡슐화를 재귀적으로 한다.   


## 7.2 컬렉션[^1] 캡슐화하기   
**배경**   
<내부 컬렉션을 직접 수정하지 못하게 막는 방법>   
1. 컬렉션 값을 반환하지 않도록 컬렉션 접근 시 컬렉션이 소속된 클래스의 적절한 메서드를 반드시 거치게 한다.   
ex) aCustomer.orders.size() -> aCustomer.numberOfOrders()   
위와 같은 방법도 있지만 부가적인 코드가 늘어나고 컬렉션 연산들을 조합해서 사용하기 어려워 컬렉션 파이프라인과 같은 패턴을 적용해서 사용하는 걸 추천한다.   

2. 컬렉션을 읽기 전용으로 제공한다.   
컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 방식을 흔히 사용한다.  


## 7.3 기본형을 객체로 바꾸기
**배경**   
개발 초기에는 단순한 정보를 간단한 데이터 항목으로 표현할 때가 많은데 개발이 진행되면서 간단했던 정보들이 더 이상 간단하지 않게 변하는 경우도 있다.   
단순한 출력 이상의 기능이 필요해지는 순간 데이터를 표현하는 전용 클래스를 정의하는 것이 프로그램이 점점 커질수록 유용한 도구가 된다.   



## 7.4 임시 변수를 질의 함수로 바꾸기
**배경**   
임시 변수를 사용하면 값을 계산하는 코드가 반복되는 걸 줄이고 변수 이름을 통해 값의 의미를 설명할 수도 있어서 유용하다.   
더 나아가 긴 한숨의 한 부분을 별도 함수로 추출하고자 할 때 변수들을 먼저 각각의 함수로 만들면 추출한 함수에 변수를 따로 전달할 필요가 없어져 일이 수월해진다.   
그렇게 하면 추출한 함수와 원래 함수의 경계가 더 분명해지기도 하는데, 부자연스러운 의존 관계나 부수효과를 찾고 제거하는 데 도움이 된다.   
변수 대신 함수로 만들어두면 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어든다.   
(변수는 값을 한 번만 계싼하고, 그 뒤로는 읽기만 해야 한다.)    
변수에 값을 한 번 대입한 뒤 더 복잡한 코드 덩어리에서 여러 차례 다시 대입하는 경우는 모두 질의 함수로 추출해야 한다.   


## 7.5 클래스 추출하기
**배경**   
메서드와 데이터가 너무 많은 클래스는 적절히 분리하는 것이 좋다.   
특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다.   
변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다.   


## 7.6 클래스 인라인하기
**배경**   
클래스를 인라인하는 이유에는 크게 2가지가 있다.   
1. 역할을 옮기는 리팩터링 후 특정 클래스에 남은 역할이 별로 없는 경우.   
-> 가장 많이 사용하는 클래스에 흡수시킨다.   
2. 두 클래스의 기능을 지금과 다르게 배분하고 싶은 경우.   
-> 흔히 코드를 재구성할 때 사용하는 방식이다. 


## 7.7 위임 숨기기
**배경**   
서버 객체의 필드가 가리키는 객체의 메서드를 호출하려면 클라이언트는 위임 객체를 알아야 한다.   
위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트는 코드를 수정해야 한다.   


## 7.8 중개자 제거하기   
**배경**   
위임 숨기기와 반대.   
클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야 하는데, 기능을 추가하다보면 단순히 전달만 하는 위임 메서드들이 성가셔진다.   
단순히 서버 클래스는 중개자 역할로 전락하여 차라리 클라이언트가 위임 객체를 직접 호출하는 게 나을 수도 있다.   

## 7.9 알고리즘 교체하기
**배경**   
더 간결한 코드를 찾으면 교체한다.   
- 목적을 달성하는 더 쉬운 코드가 있을 때
- 코드와 똑같은 기능을 제공하는 라이브러리가 있을 때
- 알고리즘을 살짝 다르게 동작하도록 바꾸고 싶을 때


[^1]: 컬렉션 프레임워크란, 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다. 자바에서의 자료구조 유형은 1) 순서가 있는 목록인 List 2) 순서가 중요하지 않은 목록인 Set 3) 먼저 들어온 것이 먼저 나가는 Queue 4) key-value의 형태로 저장되는 Map이 있다. 
