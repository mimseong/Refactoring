## CHAPTER 01 리팩터링: 첫 번째 예시

### 1.2 예시 프로그램을 본 소감
* 프로그램 작동 방식 파악을 위해 여러 함수와 프로그램 요소로 재구성하는 등 구조를 잡은 후 리팩터링 진행하기
* 하나의 함수의 복잡도가 크게 증가하지 않게 하기
* 중복 코드가 발생하기 않게 하기
* 정책은 언제든 수정 가능하다는 것 기억하기

### 1.3 리팩터링의 첫 단계
* 성공/실패를 스스로 판단할 수 있는 `테스트 코드` 작성하기

### 1.4 statement() 함수 쪼개기
* 긴 함수를 리팩터링할 때는 각각 부분으로 나눌 수 있는 지점을 찾는다.
* 함수명을 지을 때 코드가 하는 일을 설명하는 이름으로 지어주면 코드를 분석하지 않아도 된다.

#### 함수 추출하기
* 값이 바뀌지 않는 변수는 `매개변수`로, 함수 안에서 값이 바뀌는 변수는 `반환`
* 프로그램 수정을 작은 단계로 나눠 진행 → 버그를 쉽게 찾기 위함
* 좋은 코드는 하는 일이 명확히 드러나야 한다 → 변수 이름 중요
* 변수의 이름을 더 명확하게 바꾼다. (매개변수의 역할이 뚜렷하지 않을 때는 부정 관사(a/an)를 붙인다.)

#### 임시 변수 질의 함수로 바꾸기
* 계산을 할 때마다 계산로직이 매번 달라지는 경우(= 임시 변수)에는 추출해서 사용한다.
* 임시 변수는 자신이 속한 루틴에서만 의미가 있어 루틴이 길고 복잡해지기 쉽기 때문에 함수를 직접 선언해 사용하도록 한다. 

#### 변수 인라인하기
* 추출 작업 전에는 항상 지역 변수부터 제거한다. → 신경 써야 할 유효범위 대상이 줄어들어 추출 작업이 훨씬 쉬워진다. 

#### 함수 선언 바꾸기
* 호출할 함수를 바꾼다. (이름을 바꾸거나 호출할 필요가 없어졌다면 제거한다.)
  * 단번에 좋은 이름을 짓기는 쉽지 않으므로 처음에는 당장 떠오르는 최선의 이름을 사용하다가 나중에 좋은 이름이 떠오를 때 바꾸는 식이 좋은데 흔히 코드를 두 번 이상 읽고 나서야 가장 적합한 이름이 떠오르곤 한다.

#### 반복문 쪼개기
* 하나의 반복문에서 두 가지 이상의 일을 하는 경우 별도로 분리한다.
* 반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수도 있지만 성능에 미치는 영향은 미미하다.

#### 문장 슬라이드하기
* 관련된 코드들은 가까이에 모아둔다.

### 1.5 중간 점검: 난무하는 중첩 함수
최상위 statement() 함수는 출력할 문장을 생성하는 일만하고 계산 로직은 여러 개의 보조 함수로 빼내 결과적으로는 각 계산 과정은 물론 전체 흐름을 이해하기 쉬워졌다.

### 1.6 계산 단계와 포맷팅 단계 분리하기
* 복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.
* 객체를 복사할 때 가변 데이터는 금방 상할 수 있어 최대한 `불변`처럼 취급하여 복사한다. 
* 반복문도 `파이프라인`으로 바꾸면 훨씬 가벼워진다.

### 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨
* 코드량은 늘었지만 모듈화하여 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워졌다.
* 프로그래밍에서는 `명료함`이 진화할 수 있는 소프트웨어의 정수다.
* 리팩터링과 기능 추가 사이의 균형을 맞춰야 한다. → 완벽하지는 않더라도 분명 더 나아지게 만든다.

### 1.8 다형성을 활용해 계산 코드 재구성하기
* 계산 방식이 달라질 수 있는 형태의 조건부 로직은 `다형성`을 활용하는 것이 좋다.
* 일부의 경우에서만 달라지는 계산은 일반적인 경우를 기본으로 삼아 슈퍼클래스에 남겨두고, 달라지는 부분은 필요할 때 오버라이드하게 만드는 것이 좋다.

### 1.10 마치며
1장에서는 크게 세 단계로 나누어 리팩터링 했다.
1. 원본 함수를 중첩 함수 여러 개로 나눔
2. 계산 코드와 출력 코드 분리
3. 계산 로직을 다형성으로 표현
<br>
리팩터링은 대부분 코드가 하는 일을 파악하는 데서 시작한다.<br>
좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.<br>
코드는 명확해야 한다.<br>
수정 사항이 있으면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다.<br>
리팩터링의 핵심은 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 작은 단계들이 모여 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.
