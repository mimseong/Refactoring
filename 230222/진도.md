## 2장

**2.1 리팩터링 정의**

```
리팩터링: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
```

- 리팩터링 동안에는 코드가 항상 정상 작동
- 중간에 멈추더라도 정상 작동해야 한다
- 리팩터링 전후 코드는 같아야 한다
- 버그도 그래도 남아있어야 한다
- 리팩터링의 목적: 코드를 이해하고 수정하기 쉽게 만들기

**2.2 두 개의 모자**

- 기능 추가 / 리팩터링 명확히 구분해 작업
- 기능 추가: 기존 코드 건드리지 않고 새 기능 추가
- 리팩터링: 기능 추가 하지 않고 코드 재구성 전념

**2.3 리팩터링 하는 이유**

- 리팩터링하면 소프트웨어 설계가 좋아진다
  - 리팩터링하지 않으면 아키텍쳐가 썩기 쉽다
  - 코드 파악 어렵 -> 설계 유지 어렵 -> 설계가 빠르게 부패한다
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다
  - 기능 추가에만 집중하지 말자
  - 코드를 다룰 개발자를 배려하자
  - 코드를 이해하기 쉬우면 버그도 찾기 쉽다
- 리팩터링하면 버그를 쉽게 찾을 수 있다
  - 구조를 명확히 다듬다보면 버그들이 보인다
- 리팩터링하면 프로그래밍 속도를 높일 수 있다
  - 초기에는 빨랐지만 가면 갈 수록 기능 추가 시간 오래 걸린다
  - 버그도 자주 발생하고 해결하는데도 시간이 오래 걸린다
  - 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지 쉽게 찾을 수 있다
  - 전체 중 작은 일부부만 이해해도 된다
  - 지속적인 리팩터링으로 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다

**2.4 언제 리팩터링해야 할까?**

- 비슷한 일을 세 번째 하게 되면 리팩터링
- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
  - 적절한 이름 변수
  - 함수 잘게 나누기
- 쓰레기 줍기 리팩터링
  - 비효율적인 부분을 발견하면 수정하자
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 기능을 추가하거나 버그를 잡는 동안 리팩터링을 함께 한다
  - 다른 일을 하는 중에 리팩터링 함께 진행
```
소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다
새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다
새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많다
```
- 오래 걸리는 리팩터링
  - 리팩터링 해야 할 상활레 조금씩 개선
- 코드 리뷰에 리팩터링 활용하기
  - 새로운 아이디어가 떠오르면 리팩터링해서 쉽게 구현해넣을 수 있는지부터 살펴본다
  - 코드리뷰는 코드 작성자와 함께 리뷰하는게 좋다
- 리팩터링하지 말아야 할 때
  - `리팩터링 < 새로구현`일 경우 리팩터링 하지 않는다

**2.5 리팩터링 시 고려할 문제**

- 리팩터링 한다
  - 기능을 넣기 위한 준비의 리팩터링
  - 기능 추가가 편해진다면 리팩터링부터 한다
  - 한번 본 문제 다시 봤다면 리팩터링
- 리팩터링 하지 않는다
  - 건드릴 일 없다
  - 불편한게 심하지 않다
  - 개선할 방식이 떠오르지 않는다
- 코드 소유권
  - 외부에 노출되는 부분은 수정하기 어렵다
  - 소유권을 느슨하게 하는 건?
- 브랜치
  - 독립 브랜치로 오래 작업할 수록 작업 결과를 마스터로 통합하기 어렵다
  - 머지와 통합 구분하기 (이해하지못함)
  - 브랜치의 통합 주기 2~3일 단위로 짧게 관리
  - CI: 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다
    - 마스터 건강하게 유지해야하며
    - 기능을 잘게 쪼개야 하며
    - 기능 토글 적용해서 작업을 완료하지 않았을 때 끌 수 있도록
  - 머지 과정에서 충돌이 생기기 쉽다
  - 머지를 자주자주하면 충돌을 미리 해결할 수 있다
  - 통합 주기만큼은 짧게 잡아야 한다
 - 테스팅
   - 오류를 빨리 잡는게 핵심
   - 자가 테스트 코드 (이해못함)
   - 리팩터링 과정에서 버그 발생 불안감 해소 가능
- 레거시 코드
  - 레거시 코드의 테스트 보강은 까다롭다
  - 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트 할 수 있다
  - 그런 시스템이라면 애초에 테스트가 있을 것이다
  - 자주 보는 부분을 더 많이 리팩터링 한다
- 데이터베이스 
  - 점진적으로 변경한다 (이해못함)

**2.6 리팩터링, 아키텍쳐, 애그니(YAGNI)**

```
리팩터링이 아키텍쳐에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는데 있다.
코딩 전에 아키텍쳐를 확정지으려 할 때의 대표적인 문제는 소프트웨어 요구사항을 사전에 모두 파악해야 한다는 것이다. 
하지만 막상 해보면 실현할 수 없는 목표일 때가 많다.
우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다하다.
```
- 추측하지 않고 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축
- 복잡도를 높일 유연성 매커니즘은 검증 거친 후 추가
- 유연성 매커니즘: 향후 변경에 유연하게 대처할 수 있게 구현
- YAGNI: you aren't going to need it

**2.8 리팩터링과 성능**

- 전체 코드 중 극히 일부에서 대부분의 시간을 소비
- 코드 전체를 고르게 최적화한다면 90%는 효과가 거의 없다
- 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는 데 집중





