## 3장

코드에서 나는 악취

- 리팩터링을 언제 해야 하는가
- 코드가 풍기는 악취가 무엇인지 찾자
- 이후 6~12장에서 냄새를 없애보자

### 기이한 이름

- 코드는 단순하고 명료하게 작성해야 한다
- 마땅한 이름이 떠오르지 않는다면
- 더 근본적인 문제가 있을 것이다

### 중복 코드

- 중복인 코드를 줄이자
- 코드가 중복되면 각각 차이점이 없는지 살펴봐야 한다

### 긴 함수

- 이해하기 어렵다
- 함수가 짧으면 왔다갔다 어렵지 않을까?
- 이름을 잘 지어두면 본문을 안 봐도 된다
- 주석을 달아야 할 부분은 함수로 만든다
- 조건문도 함수로 추출하기
- 반복문도 함수로 추출하기
- 반복문이 쉽게 쪼개지지 않으면 성격이 다른 두 작업이 섞여있다

### 긴 매개변수 목록

- 질의 함수로 바꾸기
- 객체 통째로 넘기기
- 플래그 인수 제거하기
  - 플래그 인수는 인자로 함수의 로직을 선택
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 클래스로 묶기

### 전역 데이터

- 전역 데이터는 코드 베이스 어디에서든 건드릴 수 있다
- 전역 변수 함수로 감싸기

### 가변 데이터

- 데이터를 변경 시 예상하지 못한 곳에서 문제가 발생할 수 있다
- 함수형
  - 데이터는 절대 변하지 않고 데이터를 변경하려면 반드시 복사본을 만들어서 반환한다
- 가변 데이터를 방지하는 다양한 방법이 존재한다

### 뒤엉킨 변경

- 하나를 바꿨는데 다른 것들을 줄줄이 바꿔야 하는 상황
- 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리
- 데이터베이스에서 데이터를 가져와서 금융 상품 로직에서 처리한다면
- 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하는 식으로 단계 분리

### 산탄총 수술

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우
- 변경되는 대상들을 한 모듈로 합친다

### 뒤엉킨 변경 vs 산탄총 수술 

- 공통점
  - 맥락을 잘 구분 못함 -> 맥락을 명확히 구분해야 함
- 뒤엉킨 변경
  - 한 코드에 섞여 들어감
  - 맥락별로 분리해야함
- 산탄총 수술
  - 여러 코드에 흩뿌려짐
  - 맥락별로 모아야 함

### 기능 편애

- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다, 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때
- 모듈 영역 안에서는 호출 ⬆️, 모듈끼리는 호출 ⬇️
- 가까이하고 싶은 곳으로 옮겨준다

### 데이터 뭉치

- 몰려다니는 데이터 뭉치는 합쳐준다
- 클래스로 추출
- 관련 함수들도 모아보자

### 기본형 집착

- 화폐, 좌표, 구간, 전화번호 등은 기본형 대신 클래스로 묶자

### 반복되는 switch 문

- 하나의 switch: 상관없다
- 똑같은 조건을 사용하는 중복 switch는 분리해야 한다: 변경시 일일히 수정해줘야 한다

### 반복문

- 반복문을 파이프라인으로 만들기

### 성의 없는 요소

- 허접한 함수나 클래스
- 나중에 더 필요할거야~
- 리팩터링 하다보니 이렇게 됐네~
- 다시 돌려놓자

### 추측성 일반화

- 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다
- 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 죽은 코드 제거하기로 날려버리자

### 임시 필드

- 모든 필드가 채워져있다고 가정하지만 특정 상황에서만 필드가 채워지는 경우

### 메시지 체인

- 객체에서 객체를 요청하고 있다
- aPerson.department.manager.name
- 함수로 빼고 aPerson을 넘긴다

### 중개자

- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우
- 과하게 위임하지 말자

### 내부자 거래

- 은밀하게 데이터를 주고받으면 때어놓는다

### 거대한 클래스

- 클래스가 너무 많은 일을 하고 있다
- 필드가 너무 많다 -> 클래스로 추출한다
- 코드량이 많다 -> 코드의 중복을 제거한다

### 서로 다른 인터페이스의 대안 클래스들

- A: 버스클래스, B: 택시클래스
- a함수: 운전, b함수: 이동
- a와 b의 이름이 다른데 동일한 기능을 한다
- 인터페이스를 같게 맞춰주고 슈퍼 클래스로 추출한다

### 데이터 클래스

- 다른 클래스가 너무 깊이까지 다룰 때가 많다
- 데이터 클래스의 게터 세터 사용하는 부분 -> 데이터 클래스 내부로 옮기기
- 중간 데이터 구조는 딱히 동작 코드를 넣을 필요가 없다

### 상속 포기

- 서브 클래스가 부모의 메서드나 데이터 일부만 받고싶은 경우
- 이전의 해법
- A클래스의 a, b함수가 있고 B클래스가 b함수만 받고 싶은 경우
- C클래스에 a함수를 옮기고 A를 상속받도록 한다
- 그러면 A에는 공통으로 사용하는 b함수만 남는다
- 하지만!!!!
- 부모의 인터페이스를 따르고 싶지 않은 경우는 상속 매커니즘을 벗어나도록 하자

### 주석

- 주석을 탈취제처럼 사용하지 말자
- 주석을 남기고 싶다면 함수로 뽑아내자

## 4장











