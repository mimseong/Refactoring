## 3장

코드에서 나는 악취

- 리팩터링을 언제 해야 하는가
- 코드가 풍기는 악취가 무엇인지 찾자
- 이후 6~12장에서 냄새를 없애보자

### 기이한 이름

- 코드는 단순하고 명료하게 작성해야 한다
- 마땅한 이름이 떠오르지 않는다면
- 더 근본적인 문제가 있을 것이다

### 중복 코드

- 중복인 코드를 줄이자
- 코드가 중복되면 각각 차이점이 없는지 살펴봐야 한다

### 긴 함수

- 이해하기 어렵다
- 함수가 짧으면 왔다갔다 어렵지 않을까?
- 이름을 잘 지어두면 본문을 안 봐도 된다
- 주석을 달아야 할 부분은 함수로 만든다
- 조건문도 함수로 추출하기
- 반복문도 함수로 추출하기
- 반복문이 쉽게 쪼개지지 않으면 성격이 다른 두 작업이 섞여있다

### 긴 매개변수 목록

- 질의 함수로 바꾸기
- 객체 통째로 넘기기
- 플래그 인수 제거하기
  - 플래그 인수는 인자로 함수의 로직을 선택
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 클래스로 묶기

### 전역 데이터

- 전역 데이터는 코드 베이스 어디에서든 건드릴 수 있다
- 전역 변수 함수로 감싸기

### 가변 데이터

- 데이터를 변경 시 예상하지 못한 곳에서 문제가 발생할 수 있다
- 함수형
  - 데이터는 절대 변하지 않고 데이터를 변경하려면 반드시 복사본을 만들어서 반환한다
- 가변 데이터를 방지하는 다양한 방법이 존재한다

### 뒤엉킨 변경

- 하나를 바꿨는데 다른 것들을 줄줄이 바꿔야 하는 상황
- 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리
- 데이터베이스에서 데이터를 가져와서 금융 상품 로직에서 처리한다면
- 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하는 식으로 단계 분리

### 산탄총 수술

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우
- 변경되는 대상들을 한 모듈로 합친다

### 뒤엉킨 변경 vs 산탄총 수술 

- 공통점
  - 맥락을 잘 구분 못함 -> 맥락을 명확히 구분해야 함
- 뒤엉킨 변경
  - 한 코드에 섞여 들어감
  - 맥락별로 분리해야함
- 산탄총 수술
  - 여러 코드에 흩뿌려짐
  - 맥락별로 모아야 함

### 기능 편애

- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다, 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때
- 모듈 영역 안에서는 호출 ⬆️, 모듈끼리는 호출 ⬇️
- 가까이하고 싶은 곳으로 옮겨준다

### 데이터 뭉치

- 몰려다니는 데이터 뭉치는 합쳐준다
- 클래스로 추출
- 관련 함수들도 모아보자

### 기본형 집착

- 화폐, 좌표, 구간, 전화번호 등은 기본형 대신 클래스로 묶자

### 반복되는 switch 문

- 하나의 switch: 상관없다
- 똑같은 조건을 사용하는 중복 switch는 분리해야 한다: 변경시 일일히 수정해줘야 한다

### 반복문

- 반복문을 파이프라인으로 만들기

### 성의 없는 요소

- 허접한 함수나 클래스
- 나중에 더 필요할거야~
- 리팩터링 하다보니 이렇게 됐네~
- 다시 돌려놓자

### 추측성 일반화

- 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다
- 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 죽은 코드 제거하기로 날려버리자

### 임시 필드

- 모든 필드가 채워져있다고 가정하지만 특정 상황에서만 필드가 채워지는 경우

### 메시지 체인

- 객체에서 객체를 요청하고 있다
- `aPerson.department.manager.name`
- 함수로 빼고 `aPerson`을 넘긴다

### 중개자

- 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하는 경우
- 과하게 위임하지 말자

### 내부자 거래

- 은밀하게 데이터를 주고받으면 때어놓는다

### 거대한 클래스

- 클래스가 너무 많은 일을 하고 있다
- 필드가 너무 많다 -> 클래스로 추출한다
- 코드량이 많다 -> 코드의 중복을 제거한다

### 서로 다른 인터페이스의 대안 클래스들

- A: 버스클래스, B: 택시클래스
- a함수: 운전, b함수: 이동
- a와 b의 이름이 다른데 동일한 기능을 한다
- 인터페이스를 같게 맞춰주고 슈퍼 클래스로 추출한다

### 데이터 클래스

- 다른 클래스가 너무 깊이까지 다룰 때가 많다
- 데이터 클래스의 게터 세터 사용하는 부분 -> 데이터 클래스 내부로 옮기기
- 중간 데이터 구조는 딱히 동작 코드를 넣을 필요가 없다

### 상속 포기

- 서브 클래스가 부모의 메서드나 데이터 일부만 받고싶은 경우
- 이전의 해법
- A클래스의 a, b함수가 있고 B클래스가 b함수만 받고 싶은 경우
- C클래스에 a함수를 옮기고 A를 상속받도록 한다
- 그러면 A에는 공통으로 사용하는 b함수만 남는다
- 하지만!!!!
- 부모의 인터페이스를 따르고 싶지 않은 경우는 상속 매커니즘을 벗어나도록 하자

### 주석

- 주석을 탈취제처럼 사용하지 말자
- 주석을 남기고 싶다면 함수로 뽑아내자

## 4장

- 테스트 구축하기
- 리팩터링을 제대로 하려면 불가피하게 저지르는 실수를 잡아주는 테스트 스위트가 뒷받침돼야 한다

### 자가 테스트 코드의 가치

- 모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자
- 직전까지 테스트가 성공했다면 마지막 테스트 이후 작성한 코드에 버그가 있다
- 의심되는 부분이 적다! 최근에 작성한 코드라 기억이 생생하다
- 디버깅 시간이 줄어든다
- 곧바로 리팩터링하지 않고, 먼저 자가 테스트 코드부터 작성한다

### 테스트할 샘플 코드

### 첫 번째 테스트

- 테스트가 잘 통과한다
- 그러면 오류를 넣어서 테스트가 실패하는지 살펴보기
- 실패한 테스트가 하나라도 있으면 리팩터링하면 안 된다

### 테스트 추가하기

- 테스트는 위험 요인을 중심으로 작성해야 한다
- 테스트의 목적: 버그를 발견하기
- 단순한 접근자는 테스트할 필요가 없다
- 적은 수의 테스트로 큰 효과를 보자

📕테스트 작성 방법
- 테스트를 수행해서 프로그램이 내놓는 값으로 대체한다
- 기존 코드에 오류를 넣어서 실패하는지 확인한다
- 다시 되돌린다

📕테스트 코드의 중복
- 테스트 코드에서도 중복을 의심해보자
- 단순히 테스트 스위트 밖으로 빼낸다면?
- `const asia = new Province(sampleProvinceDate());`
- 참조상수라 객체의 값이 변경될 수 있다
- 이럴 경우 다른 테스트가 문제 생긴다
- `beforeEach`에서 테스트마다 새로운 asia 사용하도록 변경

📕`beforeEach`에 있는 것을 it블록에 넣는다면?
- 테스트들이 똑같은 픽스쳐에 기초하여 검증
- 표준 픽스쳐에 익숙해져서 테스트할 속성을 다양하게 찾아낼 수 있다
- beforeEach는 표준 픽스쳐를 사용한다는 사실을 알려준다
- describe 블록 안의 모든 테스트가 똑같은 기준 데이터로부터 시작한다

### 픽스쳐 수정하기

- `설정-수행-검증` 형식
- it 구문 하나당 검증도 하나씩만 하는 게 좋다
- 앞 검증 실패시 나머지 검증은 실행도 못해본다
- 실패 원인을 파악하는데 유용한 정보를 놓칠 수 있다

### 경계 조건 검사하기

- 범위를 벗어나는 경계 지점에서 문제가 생기는 경우 테스트
- 실패: 예상과 다른 값이 나옴
- 에러: 검증 전에 예외 상황이 발생함
- 코드에서 처리 과정이 복잡한 부분을 찾아보자
- 함수에서 오류가 생길만한 부분을 찾아보자

### 끝나지 않은 여정

- 기능을 새로 추가할 때마다 테스트도 추가
- 기존 테스트도 다시 살펴본다
- 기존 테스트가 충분히 명확한지
- 테스트 과정을 더 이해하기 쉽게 리팩터링할 수는 없는지
- 제대로 검사하는지
- 버그를 발견하는 즉시 발견한 버그를 잡는 테스트부터 작성하자!!
