
# CHATPER 01 리팩터링: 첫 번째 예시

## 1.1 자, 시작해보자!
  - 연극 청구 프로그램의 예시
 
 
## 1.2 예시 프로그램을 본 소감
  - 컴파일러: 코드가 지저분하든 말든 신경 안씀!
  - 인간: 코드가 읽기 어려우면 힘들어한다!
    - 설계가 나쁜 시스템은 수정할 부분을 찾고, 기존 코드와 맞물려 작동하게 할 방법을 강구하기 어렵다.


  - 리팩터링 방식
    - 코드를 여러 함수와 프로그램 요소로 재구성하기
    
  - 리팩터링이 필요한 이유
    - 요구사항의 변경에 대처하기 위해서


## 1.3 예시 코드의 리팩터링 단계
> 청구내역을 HTML로 출력하는 기능 요구사항이 추가되었다!
### 1. 테스트코드 작성
  - 성공/실패 여부를 자가진단할 수 있는 테스트를 작성한다.
### 2. 함수 쪼개기
  1. 전체 동작을 각각의 부분으로 나눌 수 있는 지점 찾기
  2. 별도 함수로 분리 후, 새 함수에서 당장 쓸 수 없는 변수가 있는지 찾기
      - 함수 안에서 값이 바뀌지 않으면 매개변수로 전달
      - 함수 안에서 값이 바뀌면 초기화 코드를 넣어주고 return 해주기
  3. 추출한 함수를 명확하게 표현할 수 있게 수정하기
      - 변수 이름 바꾸기
  4. 매개변수로 전달할 필요 없는 변수 찾기
  5. 임시변수를 질의함수로 바꾸고 인라인하기 (*임시변수: scope 안에서 전역변수처럼 사용되는 변수)
      - 임시변수는 자신이 속한 루틴에서만 의미가 있어 루틴이 길고 복잡해지기 쉽다.
      - 함수를 직접 선언하기
  6. 함수의 역할을 잘 드러내는 이름으로 바꾸기(함수 선언 바꾸기)
  7. 반복문 쪼개기
      - as-is: for문 안에서 result 스트링, 총액, 적립 포인트 계산을 같이 하고 있음.
      - 기존 반복문에서 적립포인트 누적 로직을 별도 for문으로 분리
      - 적립포인트 계산 로직을 별도 함수로 추출
      
### 3. 중첩함수 분리하기 (계산과 포맷팅 분리하기)
  1. 함수 추출
  2. 중간 데이터 구조 생성
  3. 매개변수 삭제
  4. 고차함수 사용하기(반복문을 파이프라인으로 바꾸기)
  5. 계산 부분과 중간데이터 처리 부분을 별도 함수, 별도 파일로 분리하기
    
### 4. 다형성 활용하기
  > 연극 장르 추가 & 공연마다 공연료, 적립포인트 계산법 다르게 변경!

  - 조건부 로직은 코드 수정 횟수가 늘어남에 따라 복잡해질 수 있음
    -> 언어가 제공하는 구조적인 요소로 보완 필요
    
  - 객체지향의 핵심 특성인 **다형성(polymorphism)** 활용 (조건부 로직을 다형성으로 바꾸기)
  - 상속 계층 구성하여 각 공연별 서브클래스가 각자의 구체적인 계산 로직을 정의하도록 만드는 것.
  
  1. 상속 계층 만들기
      - 공연료와 적립포인트 함수를 담을 클래스 생성
      - 공연료, 적립 포인트 계산 함수를 새로 생성한 클래스로 옮기기
  2. 다형성 지원하게 만들기
      - 타입 코드를 서브클래스로 바꾸기
        - 타입 코드: 비슷한 대상을 특성에 따라 구분해야할 때 쓰는 수단(ex. switch문)
      - 생성자를 팩터리 함수로 바꾸기
        - 생성자(new PerformanceCalculator())는 서브클래스의 인스턴스를 반환할 수 없음
        - 대신 어떤 서브클래스를 반환할지 선택할 수 있는 팩터리 함수를 생성하자
          ```js
            function createPerformanceCalculator(aPerformance, aPlay) {
              switch(aPlay.type) {
                // 공연 타입에 따라 다른 서브클래스를 생성 & 반환
                case "tragedy" : return new TragedyCalculator(aPerformance, aPlay);
                case "comedy" : return new ComedyCalculator(aPerformance, aPlay);
                default:
                  throw new Error(`알 수 없는 장르: ${aPlay.type}`);
              }
            }
          ```
      - 조건부 로직을 다형성으로 바꾸기
        - 각 서브클래스에 각 공연의 계산 로직을 추가(getter 함수)
        - 일반적인 경우에 해당하는 로직은 슈퍼클래스에, 특정 서브클래스에만 사용되는 로직은 서브클래스에 작성하여 오버라이드
        - 슈퍼클래스의 필요없는 계산 로직은 삭제 (혹은 메모 남기기..) 

## 1.10 마치며
예시 코드 리팩터링의 큰 단계
1. 원본 함수를 중첩 함수 여러개로 나누기
2. 단계 쪼개기 (계산 코드/출력 코드 분리)
3. 조건부 로직은 다형성으로 바꾸기

> 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
    
## 리팩터링 시 기억할 점
- 작은 단계로 나눠 진행하기
  - 리팩터링 중간에 실수하더라도 버그를 쉽게 찾을 수 있도록 작은 단계로 나누어 테스트하고 커밋하기
  - 더 빠르게, 깨지지 않는 코드를 작성할 수 있다.
- 아주 단순한 리팩터링을 진행했어도 꼭 테스트를 돌려보기
- 리팩터링과 성능의 관계?
  - 리팩터링한 코드가 더 성능이 떨어질 수 있다. 하지만 심각한 영향 x. 만약 느려지더라도 성능 개선이 더 쉽다.
  - 특별한 경우가 아니라면 일단 무시하라.
- 리팩터링 후 코드량이 더 늘었다?
  - 함수를 추출하면서 코드량이 늘어날 수 있음
  - 추가된 코드 덕분에 전체 로직의 구성요소가 더 뚜렷해짐
  - 계신 부분과 출력 부분이 분리됨
  - 모듈화를 통해 각 부분과 그 부분들이 서로 맞물려 동작하는 과정을 파악하기 쉬워짐
  - 결국, 계산 로직의 중복 없이 HTML 출력 버전을 만들 수 있게 됨.
  
