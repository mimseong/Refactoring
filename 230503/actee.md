# 12. 상속 다루기

## 12.1 메서드 올리기

- <-> 메서드 내리기

```js
class Emp {}
class Sales extends Emp {
  get name() {}
}
class Engineer extends Emp {
  get name() {}
}
```

```js
class Emp {
  get name() {}
}
class Sales extends Emp {}
class Engineer extends Emp {}
```

- 중복 코드 제거
- 참조하는 필드들이 서브 클래스에만 있을 시 필드들을 슈퍼 클래스로 올린 후 메서드를 올려야함

### 절차

1. 똑같이 동작하는 메서드인지 확인하기
   - 실질적으로 하는 일은 같지만 코드가 다르다면 코드가 같아질 때까지 리팩터링 하기
1. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래에서도 호출하고 참조할 수 있는지 확인하기
1. 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼 클래스에서 사용하고 싶은 형태로 통일하기
1. 슈퍼 클래스에 새로운 메서드를 생성하고 대상 메서드의 코드르 복사하기
1. 정적 검사
1. 서브 클래스 중 하나의 메서드 제거
1. 테스트
1. 모든 서브 클래스의 메서드가 없어질 때까지 제거하기

## 12.2 필드 올리기

- <-> 필드 내리기

```js
class Emp {}
class Sales extends Emp {
  protected String name;
}
class Engineer extends Emp {
  protected String name;
}
```

```js
class Emp {
  protected String name;
}
class Sales extends Emp {}
class Engineer extends Emp {}
```

- 데이터 중복 선언 줄어듦

### 절차

1. 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 확인하기
1. 필드들의 이름이 다르다면 같은 이름으로 변경하기
1. 슈퍼 클래스에 새로운 필드 생성하기
1. 서브 클래스의 필드 제거
1. 테스트

## 12.3 생성자 본문 올리기

```js
class Party {}

class Emplyee extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this.id = id;
    this.name = name;
    this.monthlyCost = monthlyCost;
  }
}
```

```js
class Party {
  constructor(name, id) {
    this.id = id;
    this.name = name;
  }
}

class Emplyee extends Party {
  constructor(name, id, monthlyCost) {
    super(name, id);
    this.monthlyCost = monthlyCost;
  }
}
```

- 생성자를 팩터리 함수로 바꾸기를 고려해보아도 됨

### 절차

1. 슈퍼 클래스에 생성자가 없다면 정의하기, 서브 클래스의 생성자들에서 이 생성자가 호출 되는지 확인하기
1. 문장슬라이드하기로 공통문장 모두를 super() 호출 직후로 옮기기
1. 공통코드를 슈퍼 클래스에 추가하고 서브 클래스들에서는 제거하기, 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 보내기
1. 테스트
1. 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용하기

   ```js
   class Emp {
     constructor(name) {}
     get isPrivileged() {}
     assignCar() {}
   }
   class Manager extends Emp {
     constructor(name, grade) {
       super(name);
       this.grade = grade;
       if (this.isPrivileged) this.assginCar(); // 모든 서브 클래스가 수행
       // 이 함수는 grade가 대입돼야 실행 가능함 --> 해당 부분을 함수로 추출한 후에 슈퍼 클래스로 옮기기
     }
     get isPrivileged() {
       return this.grade > 4;
     }
   }
   ```

   ```js
   class Emp {
     constructor(name) {}
     get isPrivileged() {}
     assignCar() {}

     finishContruction() {
       // 그럼 얘는 언제 불러??? 어디서 불러? emp constructor 에서 부르나?
       if (this.isPrivileged) this.assignCar();
     }
   }
   class Manager extends Emp {
     constructor(name, grade) {
       super(name);
       this.grade = grade;
     }
   }
   ```

## 12.4 메서드 내리기

- <-> 메서드 올리기
- 특정 서브 클래스들이랑만 관련된 메서드는 내리는게 나음

### 절차

1. 대상 메서드를 모든 서브 클래스에 복사하기
1. 슈퍼 클래스에서 해당 메서드 제거하기
1. 테스트
1. 해당 메서드를 사용하지 않는 서브 클래스에서 제거
1. 테스트

## 12.5 필드 내리기

- <-> 필드 올리기
- 특정 서브 클래스에서만 쓰는 필드는 내리기

### 절차

1. 대상 필드를 모든 서브 클래스에 정의하기
1. 슈퍼 클래스에서 해당 필드 제거하기
1. 테스트
1. 필드를 사용하지 않는 서브 클래스들에서 제거하기
1. 테스트

## 12.6 타입 코드를 서브 클래스로 바꾸기

- <-> 서브 클래스 제거하기
- 대상 클래스에 직접 적용 - 직원의 하위 타입으로 엔지니어 만들기
- 타입 코드 자체에 적용 - 직원에게 유형 속성 부여, 속성을 클래스로 정의

### 절차

1. 타입코드 필드를 자가 캡슐화 하기
1. 타입 코드 값 하나를 선택해 그 값에 해당하는 서브 클래스 만들기. 타입코드 게터 메서드를 오버라이드 하여 해당 타입 코드의 리터럴 값을 반환하게 하기
1. 매개별수로 받은 타입코드와 방금 만든 서브 클래스를 매핑하는 선택 로직을 만들기
1. 테스트
1. 타입 코드 값 각각에 대해 서브 클래스 생성과 선택 로직 추가를 반복하기. 클래스 하나가 완성될 때마다 테스트
1. 타입 코드 필드를 제거하기
1. 테스트
1. 타입코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용하기

> 직접상속 최종코드에서.. createEmployee는 언제 호출함?

## 12.7 서브 클래스 제거하기

- <-> 타입코드를 서브 를래스로 바꾸기
- 서브 클래스가 더이상 쓰이지 않을 시 서브 클래스를 슈퍼 클래스의 필드로 대체해 제거하기

### 절차

1. 서브 클래스의 생성자를 팩터리함수로 바꾸기
1. 서브 클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼 클래스로 옮기기. 변경 시 마다 테스트
1. 서브 클래스의 타입을 나타내는 필드를 슈퍼 클래스에 만들기
1. 서브 클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정하기
1. 서브 클래스 지우기
1. 테스트

## 12.8 슈퍼 클래스 추출하기

- 비슷한 일을 수행하는 두 클래스가 있을 시 상속 메커니즘을 이용해 비슷한 부분을 공통의 슈퍼 클래스로 옮겨 담기

  - 데이터 : 필드올리기
  - 동작 : 메서드 올리기

- 대안 : 클래스 추출하기 (상속대신 위임 이용)

### 절차

1. 빈 슈퍼 클래스를 만들기. 원래 클래스들이 새 클래스르 상속하도록 변경하기
1. 테스트
1. 생성자 본문 올리기, 메서드올리기, 필드올리기를 차례대로 적용해 공통 원소를 슈퍼 클래스로 옮기기
1. 서브 클래스에 남은 메서드들을 검토하기, 공통되는 부분이 있다면 함수로 추출한 다음 메소드 올리기를 적용하기
1. 원래 클래스들을 사용하는 코드를 검토하여 슈퍼 클래스의 인터페이스를 사용하게 할지 고민해보기

## 12.9 계층 합치기

- 어떤 클래스와 부모 클래스가 너무 비슷해져 더는 독립적으로 존재할 이유가 없을 때 합치기

### 절차

1. 두 클래스 중 제거할 것을 고르기
1. 필드 올리기와 메소드 올리기/필드 내리기와 메서드 내리기를 적용해 모든 요소를 하나의 클래스로 옮기기
1. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고치기
1. 빈 클래스 제거
1. 테스트

## 12.10 서브 클래스를 위임으로 바꾸기

## 12.11 슈퍼 클래스를 위임으로 바꾸기
