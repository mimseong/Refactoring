# 6장 기본적인 리팩터링

### 함수 추출하기

- 목적과 구현을 분리
- 함수의 코드가 5~6줄을 넘어갈 때 냄새
- 한 줄짜리 함수도 가능
- ex) def highlight() = reverse()

**절차**

- 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다 (`어떻게`가 아니라 `무엇을` 하는지가 드러나야 한다)
- 추출한 코드를 새 함수로 붙여넣는다
- 지역변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사
- 변수 다 처리했다면 컴파일
- 새로운 함수를 호출하도록 변경한다
- 테스트
- 비슷한 코드가 없는지 살핀다

**중첩함수를 왜 사용하는지?**
  - 추출한 함수에서 상위 함수의 모든 변수에 접근 가능

**값을 반환할 변수가 여러 개라면?**
- 각각을 반환하는 함수 여러 개로 추출한다
- 중첩함수로 추출하고 나서 새로운 문맥으로 옮긴다


### 함수 인라인하기

- 함수 본문이 이름만큼 명확한 경우
- 리팩터링 중 잘못 추출된 함수
- 다른 함수로 위임만 하는 함수들 -> 위임 관계가 복잡해진다

**절차**

- 다형메서드인지 확인한다 (서브클래스에서 오버라이드하는 메서드는 인라인하면 안 된다)
- 인라인할 함수를 호출하는 곳을 모두 찾는다
- 호출문을 함수 본문으로 교체한다
- 함수 정의를 삭제한다

### 변수 추출하기

- 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있다

**절차**

- 추출하려는 표현식에 부작용은 없는지 확인
- 불변 변수를 하나 선언하고 이름 붙일 표현식의 복제본을 대입
- 새로 만든 변수로 교체
- 테스트
- 다른 곳에서도 변수 교체

**??**

- 클래스 전체에 영향을 줄 때 변수가 아닌 메서드로 추출한다
- 하지만 이해가 안 됐다.........

### 변수 인라인하기

- 변수 이름이 원래 표현식과 다를 바 없을 때 -> 인라인한다

### 함수 선언 바꾸기

- 잘못 정의하면 지속적인 방해요인으로 작용하여 소프트웨어 동작을 파악하기 어려워진다
- 요구사항이 바뀔 떄 적절히 수정하기 어려워진다
- 이름이 잘못된 함수를 발견하면 더 나은 이름이 떠오르는 즉시 바꾼다
- 주석을 사용해서 함수의 목적을 설명해보자
- 더 나은 이름이 생각날 수 있다
- 매개변수 변경으로 모듈과의 결합을 제거할 수 있다
- 정답은 없다!

**마이그레이션 절차**

- 함수의 본문을 적절히 리팩터링한다
- 함수 본문을 새로운 함수로 추출
- 매개변수를 추가해야 한다면 간단한 절차를 따라 추가
- 테스트
- 기존 함수 인라인
- 이름이 임시 이름이라면 선언 바꾸기로 원래 이름으로 되돌린다
- 테스트

**정리**

- 추출한 함수를 호출한다
- 기존 함수가 deprecated됨을 나타낸다

**매개변수 추가하기**

- assert를 추가해서 확실히 사용하는지 확인하기

### 변수 캡슐화하기

- 함수: 변경하기 용이하다
- 변수: 유효범위가 넓어질수록 다루기 어려워진다
- 변수로 접근을 독점하는 함수를 만들기 (캡슐화)

**배경**

- 변수의 유효범위가 넓어질수록 다루기 어려워진다
- 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다
- 테이터 캡슐화의 이점
  - 데이터 변경할 수 있는 통로가 됨
  - 변경 전 검증
  - 젼경 후 추가로직 끼워넣을 수 있다
- 데이터 유효 범위 줄이기 위해 private 유지
- 불변 데이터 변경될 일 없어서 갱신 전 검증 필요없다

**절차**

- 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다
- 정적 검사 수행
- 변수 참조하던 부분을 캡슐화 함수 호출로 변경
- 변수의 접근 범위 제한
- 테스트

**예시**

- 읽고 쓰는 부분을 게터 세터로 변경
- 다른 파일로 옮기고 접근자만 노출
```
let defaultOwnerData = {}
export function defaultOwner() {return defaultOwner}
```
- 변수에 Data 붙이고 게터에 get 빼는 거 좋아보인다

**값 캡슐화하기**

- 필드값 변경 못하게 하는 방법
- 가장 간단: 그 값을 바꿀 수 없게 만드는 것
- 게터가 복제본을 반환하도록 한다
- 게터로 얻은 데이터를 변경할 수 있지만 원본에는 아무 영향을 주지 못한다
- ?? 레코드 캡슐화하기
- 세터에도 복제본을 만드는 편이 좋을 수 있다
```
set defaultOwnerData = arg
```
- arg: 이 arg가 변경되는 경우가 있으니 복사해서 저장
- 데이터의 사용 범위가 넓을수록 적절히 캡슐화하는게 좋다

### 변수 이름 바꾸기

- 변수명 간단해도 되는 경우
  - 한 줄짜리 람다식에서 사용하는 변수
  - 간단한 함수의 매개변수
- 값이 영속되는 필드라면 이름에 더 신경써야 한다

**예시**

- 넓은 범위에서 사용하는 변수의 이름 바꾸기
- 캡슐화해서 변경
- 캡슐화 그대로 유지
- 이름을 바꾸기 위해 캡슐화부터 해야 할 정도로 널리 사용되는 변수라면 나중을 위해서라도 캡슐화된 채로 두는 편이 좋다



