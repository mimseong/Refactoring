## 6.8 매개변수 객체 만들기
**배경**    
데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해지며, 함수가 이 데이터 구조를 받게 하면 매개변수 수가 줄어든다.   
또한 같은 데이터 구조를 사용하는 함수가 원소를 참조할 때 항상 같은 이름을 사용하기 때문에 일관성도 높여준다.   
저자는 이러한 데이터 구조를 발견하면 데이터 구조를 활용하는 형태로 프로그램 동작을 재구성한다고 한다.   
즉, 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출해서 함수로 만드는 것이다.   

**절차**   
- 적당한 데이터 구조가 마련되어 있지 않다면 새로 만든다. (데이터 구조를 값 객체로 만든다.)   
- 테스트한다.   
- 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
- 테스트한다. 
- 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
- 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소로 사용하도록 바꾼다.
- 다 바꿨다면 기존 매개변수를 제거하고 테스트한다. 


## 6.9 여러 함수를 클래스로 묶기
**배경**    
클래스로 묶으면 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있고, 이런 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.   
클래스로 묶을 때의 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다는 것이다.   
프로그램의 다른 부분에서 데이터를 갱신할 가능성이 있다면 클래스로 묶어두는 것이 좋다.   

**절차**   
- 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.
- 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.
- 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다. 


## 6.10 여러 함수를 변환 함수로 묶기
**배경**   
소프트웨어는 데이터를 입력받아서 여러 가지 정보를 도출하는 데 이 정보는 여러 곳에서 사용될 수 있다.   
그러다 보면 정보가 사용되는 곳마다 같은 도출 로직이 반복 되기도 하는데 도출 작업들을 한데로 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.   
이때 변환 함수를 사용할 수 있는데 변환 함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.   
다만 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하여 원본 데이터가 수정되면 일관성이 깨질 수 있다.   
따라서 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 더 낫다.   

**절차**   
- 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다.
- 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다. 
- 테스트한다.
- 나머지 관련 함수도 위 과정에 따라 처리한다.   


## 6.11 단계 쪼개기
**배경**   
서로 다른 두 대상을 한꺼번에 다루는 코드가 있다면 각각을 별개 모듈로 나누면 코드를 수정할 때 다른 모듈의 상세 내용은 몰라도 수정할곳만 신경쓰면 된다.   
분리하는 가장 편한 방법은 동작을 연이은 두 단계로 쪼개는 것이다.   
단계를 쪼개는 기법은 주로 큰 소프트웨어에 적용된다.   
다른 단계로 볼 수 있는 코드 영역들이 마침 서로 다른 데이터와 함수를 사용한다면 단계 쪼개기에 적합한 것이다.   

**절차**   
- 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
- 테스트한다.
- 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
- 테스트한다.
- 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
- 첫 번째 단계 코드를 함수로 추출하면서 중간 데이터 구조를 반화하도록 만든다. 
