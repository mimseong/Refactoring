# Chapter 07. 캡슐화
## 7.1 레코드 캡슐화하기
**배경**   
대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다.   
레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로 전달할 수 있게 해준다.   
하지만, 어떤 식으로 계산하든 **시작**과 **끝**과 **길이**를 알 수 있어야 한다.   
(계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해야 한다.)   

💫가변 데이터를 저장하는 용도로는 객체 선호   
- 객체를 사용하면 어떻게 저장했는지를 숨긴 채 시작, 끝, 길이의 값을 각각의 메서드로 제공할 수 있다. 
- 객체를 사용하면 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다.   

💫불변 데이터는 단순히 시작, 끝, 길이를 모두 구해서 레코드에 저장한다.   
<br>
레코드 구조는 2가지로 구분할 수 있다.   
1️⃣ 필드 이름을 노출하는 형태   
2️⃣내가 원하는 이름을 쓸 수 있는 형태   
ex) 해시, 맵, 해시맵, 딕셔너리, 연관 배열 등   

+) 해시맵은 다양한 작업에 유용하지만 필드를 명확히 알려주지 않는다는 게 단점이 될 수 있다.   
범위를 {시작, 끝} 혹은 {시작, 길이} 중 어느 것을 표현하고 있는지 알아내는 방법은 직접 코드를 확인하는 방법이다.   
해시맵을 쓰는 부분이 적다면 문제가 되지 않지만 사용하는 곳이 많을수록 불분명해진다.   
<br>
**절차**   
1. 레코드를 담은 변수를 캡슐화 한다.  `레코드를 캡슐화 하는 목적 : 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위함`   
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.   
3. 테스트한다.   
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.   
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.   
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.   
7. 테스트한다.   
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.     
<br>

저자는 덩치 큰 데이터 구조를 다룰 때 **데이터를 쓰는** 부분에 집중한다고 한다.   
(캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한 곳에 모아두는 일이 중요하다.)   
쓰는 부분을 찾아 수정하다보면 빠진 건 없는지 확인해야 하는데 이때 확인할 수 있는 방법은    
1. 깊은 복사하여 반환하기
2. 읽기전용 프락시 반환하기   
3. 복제본을 만들고 재귀적으로 동결해서 쓰기 동작 감지하기
<br>

그렇다면 **읽기**는 어떻게 다뤄야 할까?   
1. 읽는 코드를 모두 독립 함수로 추출한 다음 클래스로 옮긴다. 
    - 모든 쓰임을 명시적인 API로 제공한다는 건 장점. (하지만 읽는 패턴이 다양하면 그만큼 작성할 코드가 늘어난다. )   
2. 내부 데이터를 복제해서 제공한다.   
3. 레코드 캡슐화를 재귀적으로 한다.   


## 7.2 컬렉션 캡슐화하기
저자는 데이터 구조가 언제 어떻게 수정되는지 쉽게 파악하기 위해 가변 데이터를 모두 캡슐화 한다고 한다.   


