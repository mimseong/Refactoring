# CHAPTER 06. 기본적인 리팩터링

* 저자가 가장 많이 사용하는 리팩터링은 **함수 추출하기**와 **변수 추출**하기지만 반대로 진행하는 **함수 인라인**하기, **변수 인라인하기**도 자주 사용한다.   
* 추출은 이름 짓기며, **함수 선언 바꾸기**는 함수의 이름을 변경할 때 많이 쓰인다. 
* 함수의 인수를 추가하거나 제거할 때도 리팩터링 적용한다. 
  * 바꿀 대상이 변수라면 **변수 이름 바꾸기**를 사용하는데 이는 **변수 캡슐화하기**와 관련이 깊다. 
  * 자주 함께 뭉쳐다니는 인수들은 **매개변수 객체 만들기**를 적용해 하나의 객체로 묶으면 편리할 때가 많다. 
* 함수를 만들고 나면 다시 고수준 모듈로 묶어야 한다. 
  * 함수를 그룹으로 묶을 때는 **여러 함수를 클래스로 묶기**를 사용한다. 이때 함수들이 사용하는 데이터도 클래스로 함께 묶는다.
  * 읽기전용 데이터를 다룰 때는 **여러 함수를 변환 함수로 묶기**가 좋다. 
  * 조금 더 나아가 저자는 모듈의 작업 처리 과정을 명확한 단계로 구분 짓는 **단계 쪼개기**를 적용할 때도 많다. 

## 6.1 함수 추출하기
언제 함수로 묶어야 할까?
* 함수 길이를 기준으로. (ex. 함수 하나가 한 화면을 넘어가면 안 된다)
* 두 번 이상 사용될 코드일 경우(재사용성)
* 코드를 파악하는 데 시간이 걸릴 경우 (목적과 구현 분리하기)
  * 함수명은 '무슨 일'에 걸맞게 짓기
  * '어떻게'가 아닌 **'무엇을'** 하는지가 드러나도록.

**절차**
* 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다.
* 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
* 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
* 변수를 다 처리했다면 컴파일한다.
* 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다.
* 테스트한다.
* 다른 코드에 방금 추출한 것과 같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다. 

:heavy_check_mark: 함수를 짧게 만들면 캐싱하기가 더 쉬워 컴파일러가 최적화하는 데 유리할 때가 많다.   

## 6.2 함수 인라인하기
**배경**
* 함수 본문이 이름만큼 명확한 경우나 함수 본문 코드를 이름만큼 깔끔하게 리팩터링했을 때는 함수를 제거한다. (쓸데없는 간접 호출은 거슬릴 뿐)
* 리팩터링 과정에서 잘못 추출된 함수들도 다시 인라인한다. (= 원래 함수로 합친 후 필요에 의해 원하는 형태로 다시 추출하는 것.)
* 간접 호출, 즉 단순히 위임하기만 하는 함수들도 인라인해버린다.    

**절차**
* 다형 메서드(Polymorphic method)인지 확인한다.
* 인라인할 함수를 호출하는 곳을 모두 찾는다.
* 각 호출문을 함수 본문으로 교체한다.
* 하나씩 교체할 때마다 테스트한다.
* 함수 정의(원래 함수)를 삭제한다. 

:heavy_check_mark: 함수 인라인하기는 유용한 것만 남기고 나머지는 제거할 수 있다.    

## 6.3 변수 추출하기
**배경**
* 표현식이 복잡해서 이해하기 어려울 때는 지역 변수를 활용하면 단계마다 이름을 붙일 수 있어 더 쉽게 관리할 수 있다. 
* 이 과정에서 추가한 변수는 breakpoint를 지정하거나 상태를 출력하는 문장을 추가할 수 있어 디버깅에도 도움이 된다. 
* 함수 안에서만 의미가 있다면 변수로 추출하는 것이 좋으나 넓은 문맥에서까지 의미가 된다면 넓은 범위에서 통용되는 이름을 생각해야 한다. 즉, 변수가 아닌 함수로 추출해야 한다. 

**절차**
* 추출하려는 표현식에 부작용은 없는지 확인한다.
* 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.
* 원본 표현식을 새로 만든 변수로 교체한다.
* 테스트한다.
* 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다. 

:heavy_check_mark: 객체는 특정 로직과 데이터를 외부와 공유하려 할 때 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다.   
따라서 덩치가 큰 클래스에서 공통 동작을 별도 이름으로 뽑아내서 추상화해두면 그 객체를 다룰 때 쉽게 활용할 수 있어서 매우 유용하다. 

## 6.4 변수 인라인하기
* 변수는 함수에서 표현식을 가리키는 이름으로 쓰인다.
* 변수가 주변 코드를 리팩터링하는 데 방해가 된다면 그 변수를 인라인하는 것이 좋다. 


## 6.5 함수 선언 바꾸기
**배경**
* 함수는 프로그램을 작은 부분으로 나누는 주된 수단이며 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다. 
* 연결부에서 가장 중요한 요소는 함수의 이름이다.   
  * 이름이 좋으면 호출문만 보고도 무슨 일을 하는지 파악할 수 있다. 
  * 좋은 이름을 떠올리는 데 효과적인 방법으로는 주석을 이용해 함수의 목적을 설명해보는 것이다. 
* 매개변수도 마찬가지다.
  * 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다.
  * 매개변수는 함수를 사용하는 문맥을 설정한다.   

**절차**
* 간단한 절차만으로 충분할 때도 많지만 더 세분화된 마이그레이션 절차가 훨씬 적합한 경우도 많다. 
  * 따라서 변경 사항을 살펴보고 함수 선언과 호출문들을 단번에 고칠 수 있는지 가늠해본다.
    * 가능하다면 메서드 선언을 원하는 형태로 바꾸고 해당 메서드를 참조하는 부분을 모두 찾아 바뀐 형태로 수정하면 된다.
    * 호출하는 곳이 많거나, 호출 과정이 복잡하거나, 호출 대상이 다형 메서드일 때 등은 마이그레이션 절차를 이용한다. 
* 마이그레이션 절차를 적용하면 호출문들을 점진적으로 수정할 수 있다. 

:heavy_check_mark: 리팩터링은 대부분 직접 수정할 수 있는 코드지만, 함수 선언 바꾸기는 공개된 API, 즉 직접 고칠 수 없는 외부코드가 사용되는 부분을 리팩터링하기에 좋다. 

## 6.6 변수 캡슐화하기
**배경**
* 함수는 리팩터링 작업을 간소화하는 데 큰 역할을 한다. 
* 데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동하고 유효범위가 넓어질수록 다루기 어려워진다. 
  * 따라서 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 있다. 
  * 데이터 재구성을 더 단순한 작업인 함수 재구성으로 변환하는 것이다. 
* 데이터 캡슐화는 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워넣을 수 있다. 
  * 저자는 유효범위가 함수 하나보다 넓은 가변 데이터를 모두 캡슐화해서 그 함수를 통해서만 접근하게 만든다. 
  * 데이터의 유효범위가 넓을수록 캡슐화해야 한다. 
* 레거시 코드[^1]를 다룰 때는 자주 사용하는 데이터에 대한 결합도가 높아지는 일을 막기 위해 변수를 참조하는 코드를 추가하거나 변경할 때마다 최대한 캡슐화한다. 
  * 객체 지향에서 객체의 데이터를 항상 `private`로 유지해야 하는 이유도 바로 결합도가 높아지는 것을 막기 위한 것이다. 
  * 저자는 public 필드를 발견할 때마다 캡슐화하여 가시 범위를 제안하려 한다. 
* 불변 데이터는 데이터가 변경될 일이 없어서 갱신 전 검증 같은 추가 로직이 자리할 공간을 마련할 필요가 없어 가변 데이터보다 캡슐화할 이유가 적다. 
  * 또한 불변 데이터는 옮길 필요 없이 그냥 복제하면 되기 때문에 원본 데이터를 참조하는 코드를 변경할 필요도 없고, 데이터를 변형시키는 코드를 작성할 일도 없다. 

**절차**
* 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
* 정적 검사를 수행한다.
* 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
* 변수의 접근 범위를 제한한다.
* 테스트한다.
* 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다. 

**값 캡슐화하기**
위와 같은 절차는 접근이나 구조 자체를 다시 대입하는 행위는 제어할 수 있으나 필드 값을 변경하는 일은 제어할 수 없다.    
기본 캡슐화 기법은 데이터 항목을 참조하는 부분만 캡슐화한다.   
행위까지 제어할 수 있도록 캡슐화하고 싶다면 
* 그 값을 바꿀 수 없게 만든다. 
  * 저자는 게터가 데이터의 복제본을 반환하도록 수정하는 식으로 처리한다. 
  * 특히 리스트에 많이 적용하는데
  * 데이터의 복제본을 반환하면 클라이언트는 게터로 얻은 데이터를 변경할 수 있지만 원본에는 아무 영향을 주지 못하다. 
  * 만약 공유 데이터(원본)을 변경하기를 원하는 클라이언트가 있다면 레코드 캡슐화를 이용한다. 


[^1]: 다른 사람으로부터 상속 된 소스 코드, 이전 버전의 소프트웨어에서 상속 된 소스 코드, 개발자가 변경하기를 두려워하는 코드, 테스트 없는 코드 중 하나라도 포함된다면 레거시 코드
