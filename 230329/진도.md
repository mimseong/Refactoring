## 캡슐화

### 7.1 레코드 캡슐화하기

레코드
```
{name: "진도", age: 9999}
```

- 레코드의 단점: 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번거롭다
- 클래스: 사용자가 무엇이 저장된 값이고 계산된 값인지 알 필요가 없다

**예시** 

- 상수 자체를 함수로 캡슐화한다
- 객치로 만들고 객체를 반환한다
- 게터와 세터를 추가한다
- 필드로 펼쳐둔다

**예시 - 중첩된 레코드 캡슐화하기**

- 중첩된 구조 읽는 방법
- 읽는 코드를 모두 독립 함수로 빼는 방법
- 장점: 명시적이다
- 단점: 읽는 경우마다 코드 수 증가
- 복제본 제공
- 단점: 데이터 구조가 클수록 복제 비용이 증가 -> 성능이 느려질 수 있다
- 레코드 캡슐화를 재귀적으로

### 7.2 컬렉션 캡슐화하기

- 컬렉션의 원소가 바뀔 수 있다
- 복제본을 리턴하고 컬렉션 변경자 메서드 제공
- `aCustomer.oders.size()` -> `aCustomer.numberOfOders()`
- 표준 인터페이스 대신 전용 메서드들을 사용하게 하면 부가적인 코드가 상당히 늘어나며 컬렉션 연산들을 조합해 쓰기도 어려워진다
- 컬렉션 읽기 전용으로 제공

**예시**

- 컬렉션을 마음대로 수정 가능하다
- 수업을 추가하는 메서드와 수업을 제거하는 메서드 생성
- get 할 때 변경이 불가하도록 복제본 제공

### 7.3 기본형을 객체로 바꾸기

- 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스 정의
- 데이터에 특별한 동작이 필요해지면 이 클래스에 추가

### 7.4 임시 변수를 질의 함수로 바꾸기

- 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드의 중복이 줄어든다
- 여러 곳에서 똑같은 방식으로 계산되는 변수를 발견 -> 함수로 바꿀 수 있는지 생각해보자
- 아래와 같은 경우 모두 질의함수로 추출해야 함에 유의
```
a = ㅁㅁㅁ
a = ㅇㅇㅇ
```

### 7.5 클래스 추출하기

- 하나의 클래스 두 개로 쪼개기
- 클래스는 명확하게 추상화하고 소수의 주어진 역할을 처리해야 한다
- 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다

**예시**

- 사람 + 전화번호 두 가지 역할을 하고 있다
- 필드들을 하나씩 새 클래스로 옮긴다
- 불필요한 office prefix를 제거한다
- (이런 prefix가 붙으면 분리 생각해보는 것도 좋은듯)

### 7.6 클래스 인라인하기

- 더이상 제역할을 못해서 그대로 두면 안 되는 클래스: 인라인하기 

### 7.7 위임 숨기기

- 위임객체의 메서드를 호출하려면 위임 객체를 알아야 한다
- 위임 객체의 인터페이스가 바뀌면 클라이언트의 코드 수정이 필요하다
- 위임 메서드를 만들어서 위임객체 존재 숨기기

### 7.8 중개자 제어하기

- 위임 숨기기의 단점
  - 위임 객체의 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드 추가
  - 중재자 역할만 한다
  - 차라리 직접 위임 객체를 호출하는게 낫다

**예시**

- 사람 클래스의 상당 부분이 그저 위임만 한다
- 각 클라이언트가 부서 객체를 직접 사용하도록 고친다

### 7.9 알고리즘 교체하기

- 더 간명한 방법을 찾아내면 복잡한 기존 코드를 고친다
- 알고리즘 전체를 건어내고 훨씬 간결한 알고리즘으로 바꿔야 할 때가 있다


