# Chapter 03 코드에서 나는 악취

> 리팩터링을 언제 시작하고 언제 그만해야 하는가?

## 리팩터링하면 해결할 수 있는 문제의 징후들

### 3.1 기이한 이름
- 코드는 단순하고 명료하게 작성해야한다.
- 이름만 보고도 함수, 변수 등이 무슨 일을 하는 지 알 수 있도록 지어야 한다.

- 마땅한 이름이 떠오르지 않는다면 설계의 문제일 수도 있다.
- 이름을 정리하다보면 코드가 훨씬 간결해질 때가 많다.


### 3.2 중복 코드
- 똑같은 코드 구조가 반복되면 하나로 통합하면 좋다.
- 코드가 비슷하긴 한데 완전 똑같지는 않다면, 문장 슬라이드하기로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살핀다.


### 3.3 긴 함수
- 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성된다.
- 간접 호출의 효과는 함수를 짧게 구성할 때 나온다.
  - 코드를 이해, 공유, 선택하기 쉬워지는 효과

- 요즘 언어는 프로세스 안에서 함수 호출 비용이 거의 없다.
- 읽는 사람 입장에서 함수 선언부와 호출부를 왔다갔다 해야한다는 부담이 있지만, 결국 이름을 잘 지으면 그럴 필요도 없다.

- 주석을 달만한/달려 있는 부분은 무조건 함수로 만든다.
- 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.

- 함수는 짧게 만드는 작업은 대부분 **함수 추출하기**를 이용한다.
- 추출한 함수의 매개변수가 너무 많다면 매개변수를 줄이는 리팩터링을 진행한다.

### 3.4 긴 매개변수 목록
- 매개변수가 늘어나면 이해하기 어려워진다.
- 리팩터링 기법을 통해 매개변수를 줄이거나 합치는 방향으로 매개변수를 정리해주면 좋다.

### 3.5 전역 데이터
- 전역 데이터는 악취 중 가장 지독한 축에 속한다.
- 전역 데이터는 코드베이스 어디서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 매커니즘이 없다.
- 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견
  - 변수 캡슐화하기(함수로 감싸기): 데이터를 수정하는 부분을 쉽게 찾고, 접근 통제할 수 있다.

### 3.6 가변 데이터
- 무분별한 데이터 수정에 따른 위험을 줄이는 방법
  - 변수 캡슐화하기로 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다.
  - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다.

### 3.7 뒤엉킨 변경
- 코드를 수정할 때는 고쳐야할 부분 딱 한군데만 찾아서 그부분만 수정할 수 있어야한다.
- 그렇지 않다면 단일 책임 원칙이 지켜지지 않는 것이다.

- 순차적으로 실행되는 로직이라면, 다음 맥락에 필요한 데이터를 특정 데이터 구조에 담아 전달하는 식으로 단계를 분리한다.(단계쪼개기)
- 처리과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈을 만들어 관련 함수를 모아둔다. (함수 옮기기)
- 여러 맥락의 일에 관여하는 함수가 있다면 함수 추출하기/클래스 추출하기부터 수행한다.

### 3.8 산탄총 수술
- 코드를 변경할 때마다 자잘하게 수정해야하는 클래스가 많을 때
- 변경할 부분이 코드 전반에 퍼져있으면 찾기 어렵고 빼먹기 쉽다.
- **함께 변경되어야하는 대상을 한 모듈**에 묶어두면 좋다.
- 어설프게 분리된 로직을 인라인하는 것도 좋은 방법이다.


### 3.9 기능 편애
- 어떤 함수가 자신이 속한 모듈보다 다른 모듈의 함수나 데이터와의 상호작용을 더 많이 할 때
- 자주 사용하는 함수/데이터 근처로 함수를 옮겨준다.

### 3.10 데이터 뭉치
- 데이터 뭉치들은 따로 분리하는 게 좋다.
- 필드 형태의 데이터 뭉치를 클래스로 추출한다.
- 메서드 시그니처에 있는 데이터 뭉치는 객체로 뽑아내 매개변수 수를 줄여본다.
  * 메서드 시그니처: 메서드 이름과 매개변수 리스트의 조합
  ```java
  public void draw(String s) {
        //…
    }

    public void draw(int i) {
        //…
    }

    public void draw(double f) {
        //…
    }

    public void draw(int i, double f) {
        //…
    }
  ```
- 간단한 레코드 구조보다는 클래스로 만드는 것이 중복을 없애는 등 향후 개발에 유용하기 때문에 추천한다.

### 3.11 기본형 집착
- 전화번호, 금액, 단위 등을 숫자나 문자열로만 표시하지 말고 주어진 문제에 딱 맞는 기초 타입을 직접 정의하자. 
- 기본형을 객체로 바꾸기 참고

### 3.12 반복되는 switch 문
- 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드를 찾아서 리팩터링 해보자.
  - 조건절 하나를 추가할 때마다 다른 switch 문도 모두 수정해야하기 때문..

### 3.13 반복문
- 반복문을 파이프라인으로 바꾸기를 통해 파이프라인 연산을 사용하도록 바꾸자.
  - filter, map 같은 함수

### 3.14 성의 없는 요소
- 필요 없거나 없는 게 더 나은 클래스나 구조는 정리하자.


### 3.15 추측성 일반화
- "나중에 필요할거야"라는 생각으로 당장은 필요없는 로직을 작성해둔 코드
- 당장 필요없다면 없애버리자!

### 3.16 임시 필드
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있다.
- 임시 필드를 포함하면 코드를 이해하기 어렵다.

- 임시 필드는 클래스 추출하기로 분리하고 임시 필드와 관련된 코드를 같은 클래스에 모아둔다.
- 임시 필드가 유효한지 확인하고 동작하는 조건부 로직이 있는 경우, 특이 케이스 추가하기로 필드가 유효하지 않을 때를 위한 대안 클래스를 만든다.

### 3.17 메시지 체인
- 메시지 체인: 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤, 방금 얻은 객체에서 또 다른 객체를 요청하는 것. 대른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드.
- 클라이언트가 객체 내비게이션 구조가 종속됐음을 의미한다.
- 혹시 중간 단계를 수정해야할 경우 클라이언트 코드도 수정해야하는 일이 생긴다.

- 최종적으로 사용하는 객체가 어떻게 쓰이는지부터 살펴보고, 체인을 숨길 수 있는지 살펴본다.

ex) 
```js
managerName = aPerson.department.manager.name;

managerName = aPerson.department.managerName; // 관리자 객체의 존재를 숨김
managerName = aPerson.manager.name; // 부서 객체의 존재를 숨김
managerName = aPerson.managerName; // 부서, 관리자 객체를 모두 숨김
```

### 3.18 중개자
- 객체에는 세부사항을 숨겨주는 캡술화 기능이 있다.
- 캡슐화하는 과정에서는 위임이 자주 활용된다. 
- 위임이 너무 많으면 문제다: 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면? 
  - 중개자 제거하기를 통해 실제로 일을하는 객체와 직접 소통하도록 하자.


### 3.19 내부자 거래
- 모듈 간의 통신은 최소한으로 줄이고, 투명하게 처리해야 한다.
- 지나지게 통신을 많이하는 모듈들은 함수 옮기기, 필드 옮기기 등을 통해 떼어놓는다.
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 위임 숨기기를 이용한다.
- 부모/자식의 상속 관계에서 서브 클래스가 커지면 서브 클래스를 위임으로 바꾸기 / 슈퍼클래스는 위임으로 바꾸기를 활용하자.

### 3.20 거대한 클래스
- 한 클래스가 너무 많을 일을 하다보면 필드 수가 많아진다.
- 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

- 클래스 추출하기로 필드 일부를 따로 묶는다.
  - 관심사가 같은 필드, 접두어나 접미어가 같은 필드 등


### 3.21 서로 다른 인터페이스의 대안 클래스들
- 다른 클래스의 두 메소드가 같은 일을하지만 다른 메소드 시그니처를 가지면 다형성을 활용하기 어렵다.
  - 메서드 시그니처를 일치시키자.
  - 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안에 생성한다.
- 대안 클래스들 사이에 중복이 생기면 슈퍼클래스 추출하기를 적용하는 것을 고려한다.


### 3.22 데이터 클래스
- 데이터 클래스: 데이터 필드와 게터/세터로만 구성된 클래스
- public 필드는 레코드 캡슐화하기로 숨겨주자.
- 변경하면 안되는 필드는 세터 제거하기로 접근을 차단하자.
- 데이터 클래스의 게터/세터를 사용하는 메서드가 있다면 그 메서드를 데이터 클래스 안으로 옮길 수 있는지 보자.
  - 메서드를 통째로 옮길 수 없다면 옮길 수 있는 부분만 뽑아내서 옮긴다.
- 데이터 클래스는 필요한 동작(메서드)가 클라이언트 코드에 정의돼 있다는 신호일 수도 있다.
  - 클라이언트 코드를 데이터 클래스로 옮겨보자.

### 3.23 상속 포기
- 서브 클래스는 부모 클래스의 메서드나 데이터를 물려받는다.
- 
- 부모 클래스의 데이터가 별로 필요 없는 경우
    - 같은 계층에 서브 클래스를 하나 만들고, 메서드 내리기와 필드 내리기를 활용해 물려받지 않을 부모 코드를 모두 옮긴다.
    - 부모에는 공통된 부분만 남게 된다.

- 서브 클래스가 부모 클래스의 메서드는 필요로 하지만 인터페이스는 따르고 싶지 않을 때
  - 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기를 통해 상속 매커니즘에서 벗어나게 하자.

### 3.24 주석
- 주석을 장황하게 다는 것은 코드가 잘못 작성되었다는 뜻일 때가 많다.
- 특정 코드 블록이 하는 일에 주석을 달고 싶다면 함수를 추출해본다.
- 추출했는데도 주석이 필요하다면 함수 이름을 바꿔본다.
- 선행 조건을 명시하고 싶다면 어서션 추가하기를 해본다.
