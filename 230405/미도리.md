
# Chapter 08 기능 이동

> 요소를 다른 컨텍스트로 옮기는 일, 즉 기능이동 역시 리팩터링의 중요한 축이다.

## 8.1 함수 옮기기

- 모듈성: 모듈화가 잘 되어있는 정도. 프로그램의 어딘가를 수정하려할 때, 해당 기능과 깊이 관련된 작은 일부분만 이해해도 수정할 수 있게 해주는 능력.

- 모듈성을 높이려면...
  - 서로 연관된 요소들을 함께 묶기
  - 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있게 하기

함수 옮기기 예시)
- 어떤 함수가 속한 모듈 A의 요소보다 모듈 B의 요소를 더 많이 참조한다면, 모듈 B로 옮기자.
  - 이 경우 캡슐화가 좋아져서, 이 소프트웨어의 나머지 부분은 모듈 B의 세부사항에 덜 의존하게 된다.
- 다른 함수 안에서 도우미 역할로 정의된 함수 중 독립적으로도 고유한 가치가 있는 것은 접근하기 더 쉬운 장소로 옮기는 게 낫다.

- 함수를 옮길지 말지 결정해야할 때는 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보자.
 - 대상 함수를 호출하는 함수들은 무엇인지
 - 대상 함수가 호출하는 함수들은 무엇인지
 - 대상 함수가 사용하는 데이터는 무엇인지

- 서로 관련된 여러 함수를 묶을 새로운 컨텍스트가 필요할 때는
  - 여러함수로 묶기
  - 클래스 추출하기

## 8.2 필드 옮기기

데이터 구조가 적절하지 않음을 깨달았다면 바로 수정해야한다.
고치지 않고 남겨진 코드는 머릿속을 혼란스럽게 하고 훗날 작성하게될 코드를 더욱 복잡하게 만들 것이다.

- 함수에 항상 함께 건네지는 데이터 조각들은 상호 관계가 명확하게 드러나도록 **한 레코드에 담는 게** 좋다.
- 한 레코드를 변경하려할 때, 다른 레코드의 필드까지 변경해아한다면 필드의 위치가 잘못되었다는 것이다.
- 구조체 여러 개에 정의된 똑같은 필드들을 갱신해야한다면, 한번만 갱신해도 되는 위치로 옮겨야 한다.

절차
1. 소스 필드가 캡슐화 되어있지 않다면 캡슐화한다.
2. 테스트
3. 타깃 객체에 필드를 생성한다.
4. 정적 검사를 수행한다.
5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.
6. 접근자들이 타깃 필드를 사용하도록 수정한다.
7. 테스트
8. 소스 필드를 제거한다.
9. 테스트


## 8.3 문장을 함수로 옮기기

특정 함수를 호출할 때 그 코드 앞 뒤에서 똑같은 코드가 추가로 실행되는 경우, 하나의 함수로 합치면 좋다.
이렇게 하면 코드를 수정할 일이 생겼을 때 한 곳만 수정하면 되므로 편해진다.

예시)
```js
  result.push(`<p>제목: ${person.photo.title}</p>`);
  result.concat(photoData(person.photo));
  
  function photoData(aPhoto) {
    return [
       `<p>위치: ${aPhoto.location}</p>`,
       `<p>날짜: ${aPhoto.data.toDateString()}</p>`
    ]
  }
```
▼

```js
  result.concat(photoData(person.photo));
  
  function photoData(aPhoto) {
    return [
       `<p>제목: ${aPhoto.title}</p>`,
       `<p>위치: ${aPhoto.location}</p>`,
       `<p>날짜: ${aPhoto.data.toDateString()}</p>`
    ]
  }
```

만약 이렇게 만든 함수를 여러 변형들로 나눠야 한다면 반대 기법인 '문장을 호출한 곳으로 옮기기'를 적용하여 뽑아낼 수 있다.


절차
1. 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 **문장 슬라이드 하기**를 이용해 함수 호출부와 가깝게 위치시킨다.
2. 타깃함수를 호출하는 곳이 한 곳뿐이라면, 옮길 코드를 잘라내어 피호출 함수로 복사하고 테스트한다.
3. 호출자가 둘 이상이라면 호출자 중 하나에서 '타깃함수 호출부분과 그 함수로 옮기려는 문장들을 함께 다른 함수로 추출한다. 추출한 함수에는 임시로 이름을 지어준다.
4. 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다. 수정할 때마다 테스트한다.
5. 모든 호출자가 새로운 함수를 사용하게 되면, 원래 함수를 새로운 함수 안으로 인라인한 후, 원래 함수를 제거한다.
6. 새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다.

## 8.4 문장을 호출한 곳으로 옮기기

만약 어떤 함수가 호출되는 곳에 따라 다르게 동작해야한다면, 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야한다.

절차
1. 호출자가 한 두개뿐이고, 피호출 함수도 간단한 상황이라면 피호출 함수의 처음 혹은 마지막을 잘라내어 호출자로 복사해 넣는다. 테스트가 통과하면 여기서 끝이다.
2. 복잡한 함수라면, 이동하지 않기를 원하는 모든 문장을 다른 함수로 추출한 다면, 임시 이름을 지어준다.
3. 원래 함수를 인라인 한다.
4. 추출된 함수의 이름을 원래 함수의 이름으로 변경한다.

## 8.5 인라인 코드를 함수 호출로 바꾸기

```js
  let appliesToMass = false;
   for(const s of states) {
    if (s === "MA") appliesToMass = true;
   }
```

▼

```js
  appliesToMass = states.includes("MA"); // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes
```

절차
1. 인라인 코드를 함수 호출로 대체한다.
2. 테스트한다.

**함수 추출하기와 다른 점**
함수 추출하기: 인라인 코드를 대체할 함수가 없을 때
인라인 코드를 함수 호출로 바꾸기: 인라인 코드를 대체할 함수가 있을 때

사용 중인 프로그래밍 언어의 표준 라이브러리나 플랫폼이 제공하는 API를 잘 알고 있을수록 이 리팩터링의 활용 빈도가 높아진다.
직접 짠 코드보다 라이브러리가 제공하는 API가 더 효율적인 가능성이 크니, 잘 알아두는 것이 좋다. (그러나 라이브러리에 지나친 의존은 금물)


## 8.6 문장 슬라이드 하기

관련된 코드들이 가까이 있도록 옮겨주는 기법. 

관련된 코드가 모여있으면 코드를 이해하기 쉽고 혹시라도 다른 리팩터링(함수 추출 등)을 할 일이 있을 때 편하다.

절차
1. 코드 조각을 이동할 위치를 찾는다. 원래 위치와 옮길 위치 사이의 코드에서 동작이 달라지는 등의 간섭이 있는 코드가 있는지 살핀다.
2. 코드 조각을 옮긴다.
3. 테스트한다.


## 8.7 반복문 쪼개기

종종 반복문 하나에서 여러가지 일을 처리하는 코드를 볼 수 있다. 한번에 여러가지 일을 수행할 수 있다는 이유에서다.
하지만 이렇게 하면, 반복문을 수정할 때마다 두가지 일을 모두 잘 이해하고 진행해야 실수하지 않을 수 있다.
반복문을 목적에 따라 분리해놓으면, 수정할 동작 하나만 잘 이해하면 된다.

반복문 안에서 여러가지 일을 수행한다면 리턴하는 값이 많아 구조체를 사용하거나 지역변수를 사용하는 일이 많을 것이다. 
반복문을 쪼갠다면 원하는 데이터를 바로 뽑아 사용할 수 있으므로 사용하는 입장에서도 편하다.

반복문을 두번 실행해야하므로 성능에 문제가 있다고 생각할 수도 있으나,
리팩터링을 먼저 깔끔히 해두고(최적화), 정말 문제가 있다면 반복문을 합치는 것은 더 쉬운일이므로 걱정하지 않아도 된다.
하지만 그런 일은 매우 드물다.


절차
1. 반복문을 복제해 두 개로 만든다.
2. 반복문이 중복되어 생기는 부수효과를 파악해서 제거한다.
3. 테스트한다.
4. 완료됐으면, 각 반복문을 함수로 추출할지 고민한다.

## 8.8 반복문을 파이프라인으로 바꾸기

```js
const names = [];
for (const p of people) {
  if(i.job === "programmer") {
    names.push(i.name);
  }
}

```

```js
const names = input.filter(i => i.job === "programmer").map(i => i.name);

```

map, filter 함수와 같은 연산을 사용하는 컬렉션 파이프라인을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다.
논리를 파이프라인으로 표현하면 객체가 코드를 따라 흐르며 어떻게 처리되는지를 읽을 수 있어 더욱 이해하기 쉬워진다.


절차
1. 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다.
2. 반복문의 첫 줄부터 시작해서 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다. 
  - 이때 컬렉션 파이프라인 연산은 1에서 만든 반복문 컬렉션 변수에서 시작하여, 이전 연산의 결과를 기초로 연쇄적으로 수행된다. 하나를 대체할 때마다 테스트한다.
3. 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다.

## 8.9 죽은 코드 제거하기

사용되지 않는 코드가 있다면, 소프트웨어의 동작을 이해하는데 커다란 걸림돌이 될 수 있다.
이런 코드를 지우지 않으면 다른 사람들이 동작하지 않는 코드를 읽고 이해하는데 시간을 허비할 수 있다.

혹시 다시 필요할 때가 온다고 하더라도 우리는 버전관리 시스템을 사용하므로 다시 살려내면 된다!

절차
1. 죽은 코드를 외부에서 참조할 수 있는 경우라면 혹시라도 호출하는 곳이 있는지 확인한다.
2. 없다면 죽은 코드를 제거한다.
3. 테스트한다.
